<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Struct - AllocatorList | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Struct - AllocatorList | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.experimental.allocator.building_blocks.allocator_list.Structs.AllocatorList">
<h1 class='section'>Struct - AllocatorList</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.experimental.allocator.building_blocks.allocator_list</dd></dl>
</div><pre><code class='lang-d'>public struct AllocatorList
{
  // Alias for `typeof(Factory()(1))` , i.e. the type of the individual allocators. 
  alias Allocator = &lt;todo: marmos support pending&gt;;
  // 
  alias SAllocator = &lt;todo: marmos support pending&gt;;

  // 
  &lt;bug: unknown&gt; addAllocator( size_t atLeastBytes ) ;
  // 
  &lt;bug: unknown&gt; addAllocator( size_t atLeastBytes ) ;
  // Allocate a block of size `s` with alignment `a` . First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling `make(s + a - 1)` and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to `alignedAllocate` will not cause more calls to `make` . 
  &lt;bug: unknown&gt; alignedAllocate( size_t s, uint theAlignment ) ;
  // Allocate a block of size `s` . First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling `make(s)` and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to `allocate` will not cause more calls to $(D make). 
  &lt;bug: unknown&gt; allocate( size_t s ) ;
  // Defined if `Allocator.deallocate` and `Allocator.owns` are defined. 
  bool deallocate( &lt;bug: unknown&gt; b ) ;
  // Defined only if `Allocator.owns` and `Allocator.deallocateAll` are defined. 
  bool deallocateAll( ) ;
  // 
  bool deallocateAll( ) ;
  // Returns `Ternary.yes` if no allocators are currently active, `Ternary.no` otherwise. This methods never returns `Ternary.unknown` . 
  Ternary empty( ) ;
  // Defined only if `Allocator.expand` is defined. Finds the owner of `b` and calls `expand` for it. The owner is not brought to the head of the list. 
  bool expand( &lt;bug: unknown&gt; b, size_t delta ) ;
  // 
  &lt;bug: unknown&gt; make( size_t n ) auto;
  // 
  void moveAllocators( &lt;bug: unknown&gt; newPlace ) ;
  // Defined only if `Allocator` defines `owns` . Tries each allocator in turn, in most-recently-used order. If the owner is found, it is moved to the front of the list as a side effect under the assumption it will be used soon. 
  Ternary owns( &lt;bug: unknown&gt; b ) ;
  // Defined only if `Allocator.reallocate` is defined. Finds the owner of `b` and calls `reallocate` for it. If that fails, calls the global `reallocate` , which allocates a new block and moves memory. 
  bool reallocate( &lt;bug: unknown&gt; b, size_t s ) ;

  // The alignment offered. 
  uint alignment;
  // 
  &lt;bug: unknown&gt; allocators;
  // If `BookkeepingAllocator` is not `NullAllocator` , `bkalloc` is defined and accessible. 
  BookkeepingAllocator bkalloc;
  // 
  Factory factory;
  // 
  __enumMember ouroboros;
  // 
  &lt;bug: unknown&gt; root;
}</code></pre><h2 class='section'>About</h2><p>Given an $(LINK2 <a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)">https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)</a>, object factory) of type <code>Factory</code> or a factory function <code>factoryFunction</code> , and optionally also <code>BookkeepingAllocator</code> as a supplemental allocator for bookkeeping, <code>AllocatorList</code> creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</p>
<p>An embedded list builds a most-recently-used strategy: the most recent allocators used in calls to either <code>allocate</code> , <code>owns</code> (successful calls only), or <code>deallocate</code> are tried for new allocations in order of their most recent use. Thus, although core operations take in theory $(BIGOH k) time for <code>k</code> allocators in current use, in many workloads the factor is sublinear. Details of the actual strategy may change in future releases.</p>
<p><code>AllocatorList</code> is primarily intended for coarse-grained handling of allocators, i.e. the number of allocators in the list is expected to be relatively small compared to the number of allocations handled by each allocator. However, the per-allocator overhead is small so using <code>AllocatorList</code> with a large number of allocators should be satisfactory as long as the most-recently-used strategy is fast enough for the application.</p>
<p><code>AllocatorList</code> makes an effort to return allocated memory back when no longer used. It does so by destroying empty allocators. However, in order to avoid thrashing (excessive creation/destruction of allocators under certain use patterns), it keeps unused allocators for a while.</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>factoryFunction</code>   </dt>
<dd>


<p>A function or template function (including function literals).</p>

</dd></dl><p>New allocators are created by calling <code>factoryFunction(n)</code> with strictly positive numbers <code>n</code> . Delegates that capture their enviroment are not created amid concerns regarding garbage creation for the environment. When the factory needs state, a <code>Factory</code> object should be used.</p>
<p>BookkeepingAllocator = Allocator used for storing bookkeeping data. The size of bookkeeping data is proportional to the number of allocators. If $(D BookkeepingAllocator) is <code>NullAllocator</code> , then <code>AllocatorList</code> is &quot;ouroboros-style&quot;, i.e. it keeps the bookkeeping data in memory obtained from the allocators themselves. Note that for ouroboros-style management, the size <code>n</code> passed to <code>make</code> will be occasionally different from the size requested by client code.</p>
<p>Factory = Type of a factory object that returns new allocators on a need basis. For an object <code>sweatshop</code> of type <code>Factory</code> , <code>sweatshop(n)</code> should return an allocator able to allocate at least <code>n</code> bytes (i.e. <code>Factory</code> must define <code>opCall(size_t)</code> to return an allocator object). Usually the capacity of allocators created should be much larger than <code>n</code> such that an allocator can be used for many subsequent allocations. <code>n</code> is passed only to ensure the minimum necessary for the next allocation. The factory object is allowed to hold state, which will be stored inside <code>AllocatorList</code> as a direct <code>public</code> member called <code>factory</code> .</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../AllocatorList/Aliases/Allocator.html">Allocator</a></td>
<td>Alias for <code>typeof(Factory()(1))</code> , i.e. the type of the individual allocators.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Aliases/SAllocator.html">SAllocator</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../AllocatorList/Functions/addAllocator.html">addAllocator</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/alignedAllocate.html">alignedAllocate</a></td>
<td>Allocate a block of size <code>s</code> with alignment <code>a</code> . First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling <code>make(s + a - 1)</code> and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to <code>alignedAllocate</code> will not cause more calls to <code>make</code> .</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/allocate.html">allocate</a></td>
<td>Allocate a block of size <code>s</code> . First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling <code>make(s)</code> and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to <code>allocate</code> will not cause more calls to $(D make).</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/deallocate.html">deallocate</a></td>
<td>Defined if <code>Allocator.deallocate</code> and <code>Allocator.owns</code> are defined.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/deallocateAll.html">deallocateAll</a></td>
<td>Defined only if <code>Allocator.owns</code> and <code>Allocator.deallocateAll</code> are defined.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/empty.html">empty</a></td>
<td>Returns <code>Ternary.yes</code> if no allocators are currently active, <code>Ternary.no</code> otherwise. This methods never returns <code>Ternary.unknown</code> .</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/expand.html">expand</a></td>
<td>Defined only if <code>Allocator.expand</code> is defined. Finds the owner of <code>b</code> and calls <code>expand</code> for it. The owner is not brought to the head of the list.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/make.html">make</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/moveAllocators.html">moveAllocators</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/owns.html">owns</a></td>
<td>Defined only if <code>Allocator</code> defines <code>owns</code> . Tries each allocator in turn, in most-recently-used order. If the owner is found, it is moved to the front of the list as a side effect under the assumption it will be used soon.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Functions/reallocate.html">reallocate</a></td>
<td>Defined only if <code>Allocator.reallocate</code> is defined. Finds the owner of <code>b</code> and calls <code>reallocate</code> for it. If that fails, calls the global <code>reallocate</code> , which allocates a new block and moves memory.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../AllocatorList/Variables/alignment.html">alignment</a></td>
<td>The alignment offered.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Variables/allocators.html">allocators</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Variables/bkalloc.html">bkalloc</a></td>
<td>If <code>BookkeepingAllocator</code> is not <code>NullAllocator</code> , <code>bkalloc</code> is defined and accessible.</td>
</tr>
<tr>
<td><a href="../AllocatorList/Variables/factory.html">factory</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Variables/ouroboros.html">ouroboros</a></td>
<td></td>
</tr>
<tr>
<td><a href="../AllocatorList/Variables/root.html">root</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
