<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Struct - KRRegion | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Struct - KRRegion | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.experimental.allocator.building_blocks.kernighan_ritchie.Structs.KRRegion">
<h1 class='section'>Struct - KRRegion</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.experimental.allocator.building_blocks.kernighan_ritchie</dd></dl>
</div><pre><code class='lang-d'>struct KRRegion( ParentAllocator = NullAllocator )
{
  // Allocates `n` bytes. Allocation searches the list of available blocks until a free block with `n` or more bytes is found (first fit strategy). The block is split (if larger) and returned. 
  void[] allocate( size_t n ) 
  // Allocates all memory available to this allocator. If the allocator is empty, returns the entire available block of memory. Otherwise, it still performs a best-effort allocation: if there is no fragmentation (e.g. `allocate` has been used but not `deallocate` ), allocates and returns the only available block of memory. 
  void[] allocateAll() 
  // 
  void assertValid( string s ) 
  // 
  auto byNodePtr() 
  // 
  void cancelRegionMode() 
  // 
  void coalesceAndMakeCircular() 
  // Deallocates `b` , which is assumed to have been previously allocated with this allocator. Deallocation performs a linear search in the free list to preserve its sorting order. It follows that blocks with higher addresses in allocators with many free blocks are slower to deallocate. 
  bool deallocate( void[] b ) @nogc nothrow
  // Deallocates all memory currently allocated, making the allocator ready for other allocations. This is a $(BIGOH 1) operation. 
  bool deallocateAll() @nogc nothrow pure
  // Returns: `Ternary.yes` if the allocator is empty, `Ternary.no` otherwise. Never returns `Ternary.unknown` . 
  Ternary empty() @nogc @safe nothrow pure
  // Adjusts `n` to a size suitable for allocation (two words or larger, word-aligned). 
  static size_t goodAllocSize( size_t n ) @nogc @safe nothrow pure
  // 
  Node* merge( Node* left, Node* right ) 
  // Checks whether the allocator is responsible for the allocation of `b` . It does a simple $(BIGOH 1) range check. `b` should be a buffer either allocated with `this` or obtained through other means. 
  Ternary owns( void[] b ) @nogc @trusted nothrow pure
  // 
  bool regionMode() 
  // 
  Node* sortFreelist( Node* root ) 
  // Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style. 
  void switchToFreeList() 
  // 
  string toString() 

  // Word-level alignment. 
  &lt;enum or auto&gt; alignment = Node.alignof
  // 
  size_t bytesUsedRegionMode = 0
  // If `ParentAllocator` holds state, `parent` is a public member of type `KRRegion` . Otherwise, `parent` is an `alias` for `ParentAllocator.instance` . 
  ParentAllocator parent
  // 
  void[] payload
  // 
  Node* root
}</code></pre><h2 class='section'>About</h2><p><code>KRRegion</code> draws inspiration from the $(MREF_ALTTEXT region allocation strategy, std,experimental,allocator,building_blocks,region) and also the $(HTTP stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book, famed allocator) described by Brian Kernighan and Dennis Ritchie in section 8.7 of the book $(HTTP amazon.com/exec/obidos/ASIN/0131103628/classicempire, &quot;The C Programming Language&quot;), Second Edition, Prentice Hall, 1988.</p>
<p>$(H4 <code>KRRegion</code> = <code>Region</code> + Kernighan-Ritchie Allocator)</p>
<p>Initially, <code>KRRegion</code> starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, <code>KRRegion.allocate</code> has the performance profile of a region allocator. Deallocation inserts (in $(BIGOH 1) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</p>
<p>Once the region cannot serve an <code>allocate</code> request, <code>KRRegion</code> switches to &quot;free list&quot; mode. It sorts the list of previously deallocated blocks by address and serves allocation requests off that free list. The allocation and deallocation follow the pattern described by Kernighan and Ritchie.</p>
<p>The recommended use of <code>KRRegion</code> is as a $(I region with deallocation). If the <code>KRRegion</code> is dimensioned appropriately, it could often not enter free list mode during its lifetime. Thus it is as fast as a simple region, whilst offering deallocation at a small cost. When the region memory is  exhausted, the previously deallocated memory is still usable, at a performance  cost. If the region is not excessively large and fragmented, the linear  allocation and deallocation cost may still be compensated for by the good locality characteristics.</p>
<p>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call $(D switchToFreeList) shortly after construction or when deemed appropriate.</p>
<p>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</p>
<p>The <code>ParentAllocator</code> type parameter is the type of the allocator used to allocate the memory chunk underlying the <code>KRRegion</code> object. Choosing the default (<code>NullAllocator</code>) means the user is responsible for passing a buffer at construction (and for deallocating it if necessary). Otherwise, <code>KRRegion</code> automatically deallocates the buffer during destruction. For that reason, if <code>ParentAllocator</code> is not <code>NullAllocator</code> , then <code>KRRegion</code> is not copyable.</p>
<p>$(H4 Implementation Details)</p>
<p>In free list mode, <code>KRRegion</code> embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</p>
<p>Similarities of <code>KRRegion</code> (in free list mode) with the Kernighan-Ritchie allocator:</p>
<p>$(UL $(LI Free blocks have variable size and are linked in a singly-linked list.) $(LI The freelist is maintained in increasing address order, which makes coalescing easy.) $(LI The strategy for finding the next available block is first fit.) $(LI The free list is circular, with the last node pointing back to the first.) $(LI Coalescing is carried during deallocation.) )</p>
<h3 class='section'>Differences from the Kernighan-Ritchie allocator</h3><p>$(UL $(LI Once the chunk is exhausted, the Kernighan-Ritchie allocator allocates another chunk using operating system primitives. For better composability, $(D KRRegion) just gets full (returns <code>null</code> on new allocation requests). The decision to allocate more blocks is deferred to a higher-level entity. For an example, see the example below using <code>AllocatorList</code> in conjunction with $(D KRRegion).) $(LI Allocated blocks do not hold a size prefix. This is because in D the size information is available in client code at deallocation time.) )</p>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/allocate.html">allocate</a></td>
<td>Allocates <code>n</code> bytes. Allocation searches the list of available blocks until a free block with <code>n</code> or more bytes is found (first fit strategy). The block is split (if larger) and returned.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/allocateAll.html">allocateAll</a></td>
<td>Allocates all memory available to this allocator. If the allocator is empty, returns the entire available block of memory. Otherwise, it still performs a best-effort allocation: if there is no fragmentation (e.g. <code>allocate</code> has been used but not <code>deallocate</code> ), allocates and returns the only available block of memory.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/assertValid.html">assertValid</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/byNodePtr.html">byNodePtr</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/cancelRegionMode.html">cancelRegionMode</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/coalesceAndMakeCircular.html">coalesceAndMakeCircular</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/deallocate.html">deallocate</a></td>
<td>Deallocates <code>b</code> , which is assumed to have been previously allocated with this allocator. Deallocation performs a linear search in the free list to preserve its sorting order. It follows that blocks with higher addresses in allocators with many free blocks are slower to deallocate.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/deallocateAll.html">deallocateAll</a></td>
<td>Deallocates all memory currently allocated, making the allocator ready for other allocations. This is a $(BIGOH 1) operation.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/empty.html">empty</a></td>
<td>Returns: <code>Ternary.yes</code> if the allocator is empty, <code>Ternary.no</code> otherwise. Never returns <code>Ternary.unknown</code> .</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/goodAllocSize.html">goodAllocSize</a></td>
<td>Adjusts <code>n</code> to a size suitable for allocation (two words or larger, word-aligned).</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/merge.html">merge</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/owns.html">owns</a></td>
<td>Checks whether the allocator is responsible for the allocation of <code>b</code> . It does a simple $(BIGOH 1) range check. <code>b</code> should be a buffer either allocated with <code>this</code> or obtained through other means.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/regionMode.html">regionMode</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/sortFreelist.html">sortFreelist</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/switchToFreeList.html">switchToFreeList</a></td>
<td>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Functions/toString.html">toString</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../KRRegion/KRRegion/Structs/Node.html">Node</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../KRRegion/KRRegion/Variables/alignment.html">alignment</a></td>
<td>Word-level alignment.</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Variables/bytesUsedRegionMode.html">bytesUsedRegionMode</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Variables/parent.html">parent</a></td>
<td>If <code>ParentAllocator</code> holds state, <code>parent</code> is a public member of type <code>KRRegion</code> . Otherwise, <code>parent</code> is an <code>alias</code> for <code>ParentAllocator.instance</code> .</td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Variables/payload.html">payload</a></td>
<td></td>
</tr>
<tr>
<td><a href="../KRRegion/KRRegion/Variables/root.html">root</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
