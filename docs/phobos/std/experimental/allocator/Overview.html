<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.experimental.allocator | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.experimental.allocator | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.experimental.allocator.Overview">
<h1 class='section'>Module - std.experimental.allocator</h1><h2 class='section'>About</h2><p>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including <code>struct</code> s and <code>class</code> es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</p>
<p>$(SCRIPT inhibitQuickIndex = 1;) $(BOOKTABLE, $(TR $(TH Category) $(TH Functions)) $(TR $(TD Make) $(TD $(LREF make) $(LREF makeArray) $(LREF makeMultidimensionalArray) )) $(TR $(TD Dispose) $(TD $(LREF dispose) $(LREF disposeMultidimensionalArray) )) $(TR $(TD Modify) $(TD $(LREF expandArray) $(LREF shrinkArray) )) $(TR $(TD Global) $(TD $(LREF processAllocator) $(LREF theAllocator) )) $(TR $(TD Class interface) $(TD $(LREF CAllocatorImpl) $(LREF CSharedAllocatorImpl) $(LREF IAllocator) $(LREF ISharedAllocator) )) $(TR $(TD Structs) $(TD $(LREF allocatorObject) $(LREF RCIAllocator) $(LREF RCISharedAllocator) $(LREF sharedAllocatorObject) $(LREF ThreadLocal) )) )</p>
<h3 class='section'>Synopsis</h3><p>$(RUNNABLE_EXAMPLE --- // Allocate an int, initialize it with 42 int* p = theAllocator.make!int(42); assert(*p == 42); // Destroy and deallocate it theAllocator.dispose(p);</p>
<p>// Allocate using the global process allocator p = processAllocator.make!int(100); assert(*p == 100); // Destroy and deallocate processAllocator.dispose(p); --- ) $(RUNNABLE_EXAMPLE --- // Create an array of 50 doubles initialized to -1.0 double[] arr = theAllocator.makeArray!double(50, -1.0); // Append two zeros to it theAllocator.expandArray(arr, 2, 0.0); // On second thought, take that back theAllocator.shrinkArray(arr, 2); // Destroy and deallocate theAllocator.dispose(arr); --- )</p>
<p>$(H2 Layered Structure)</p>
<h3 class='section'>D&#39;s allocators have a layered structure in both implementation and documentation</h3><p>$(OL $(LI A high-level, dynamically-typed layer (described further down in this module). It consists of an interface called $(LREF IAllocator), which concrete allocators need to implement. The interface primitives themselves are oblivious to the type of the objects being allocated; they only deal in <code>void[]</code> , by necessity of the interface being dynamic (as opposed to type-parameterized). Each thread has a current allocator it uses by default, which is a thread-local variable $(LREF theAllocator) of type $(LREF IAllocator). The process has a global allocator called $(LREF processAllocator), also of type $(LREF IAllocator). When a new thread is created, $(LREF processAllocator) is copied into $(LREF theAllocator). An application can change the objects to which these references point. By default, at application startup, $(LREF processAllocator) refers to an object that uses D's garbage collected heap. This layer also include high-level functions such as $(LREF make) and $(LREF dispose) that comfortably allocate/create and respectively destroy/deallocate objects. This layer is all needed for most casual uses of allocation primitives.)</p>
<p>$(LI A mid-level, statically-typed layer for assembling several allocators into one. It uses properties of the type of the objects being created to route allocation requests to possibly specialized allocators. This layer is relatively thin and implemented and documented in the $(MREF std,experimental,allocator,typed) module. It allows an interested user to e.g. use different allocators for arrays versus fixed-sized objects, to the end of better overall performance.)</p>
<p>$(LI A low-level collection of highly generic <span class="math">\((I heap building blocks)\)</span>(MDASH) Lego-like pieces that can be used to assemble application-specific allocators. The real allocation smarts are occurring at this level. This layer is of interest to advanced applications that want to configure their own allocators. A good illustration of typical uses of these building blocks is module $(MREF std,experimental,allocator,showcase) which defines a collection of frequently- used preassembled allocator objects. The implementation and documentation entry point is $(MREF std,experimental,allocator,building_blocks). By design, the primitives of the static interface have the same signatures as the $(LREF IAllocator) primitives but are for the most part optional and driven by static introspection. The parameterized class $(LREF CAllocatorImpl) offers an immediate and useful means to package a static low-level allocator into an implementation of $(LREF IAllocator).)</p>
<p><span class="math">\((LI Core allocator objects that interface with D's garbage collected heap (\)</span>(MREF std,experimental,allocator,gc_allocator)), the C <code>malloc</code> family (<span class="math">\((MREF std,experimental,allocator,mallocator)), and the OS (\)</span>(MREF std,experimental,allocator,mmap_allocator)). Most custom allocators would ultimately obtain memory from one of these core allocators.) )</p>
<p>$(H2 Idiomatic Use of <code>std.experimental.allocator</code> )</p>
<p>As of this time, <code>std.experimental.allocator</code> is not integrated with D's built-in operators that allocate memory, such as <code>new</code> , array literals, or array concatenation operators. That means <code>std.experimental.allocator</code> is opt-in$(MDASH)applications need to make explicit use of it.</p>
<p>For casual creation and disposal of dynamically-allocated objects, use $(LREF make), $(LREF dispose), and the array-specific functions $(LREF makeArray), $(LREF expandArray), and $(LREF shrinkArray). These use by default D's garbage collected heap, but open the application to better configuration options. These primitives work either with <code>theAllocator</code> but also with any allocator obtained by combining heap building blocks. For example:</p>
<p>---- void fun(size_t n) { // Use the current allocator int[] a1 = theAllocator.makeArray!int(n); scope(exit) theAllocator.dispose(a1); ... } ----</p>
<p>To experiment with alternative allocators, set $(LREF theAllocator) for the current thread. For example, consider an application that allocates many 8-byte objects. These are not well supported by the default allocator, so a $(MREF_ALTTEXT free list allocator, std,experimental,allocator,building_blocks,free_list) would be recommended. To install one in <code>main</code> , the application would use:</p>
<p>---- void main() { import std.experimental.allocator.building_blocks.free_list : FreeList; theAllocator = allocatorObject(FreeList!8()); ... } ----</p>
<p>$(H3 Saving the <code>IAllocator</code> Reference For Later Use)</p>
<p>As with any global resource, setting <code>theAllocator</code> and <code>processAllocator</code> should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.</p>
<p>To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using <code>theAllocator</code> for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</p>
<p>---- struct HashTable { private IAllocator allocator; this(size_t buckets, IAllocator allocator = theAllocator) { this.allocator = allocator; ... } // Getter and setter IAllocator allocator() { return allocator; } void allocator(IAllocator a) { assert(empty); allocator = a; } } ----</p>
<p>Following initialization, the <code>HashTable</code> object would consistently use its <code>allocator</code> object for acquiring memory. Furthermore, setting <code>HashTable.allocator</code> to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</p>
<p>$(H3 Using Allocators without <code>IAllocator</code> )</p>
<p>Allocators assembled from the heap building blocks don't need to go through <code>IAllocator</code> to be usable. They have the same primitives as <code>IAllocator</code> and they work with $(LREF make), $(LREF makeArray), $(LREF dispose) etc. So it suffice to create allocator objects wherever fit and use them appropriately:</p>
<p>---- void fun(size_t n) { // Use a stack-installed allocator for up to 64KB StackFront!65536 myAllocator; int[] a2 = myAllocator.makeArray!int(n); scope(exit) myAllocator.dispose(a2); ... } ----</p>
<p>In this case, <code>myAllocator</code> does not obey the <code>IAllocator</code> interface, but implements its primitives so it can work with <code>makeArray</code> by means of duck typing.</p>
<p>One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through <code>IAllocator</code> . An important rule of thumb is: &quot;assemble allocator first, adapt to <code>IAllocator</code> after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with <code>IAllocator</code> (usually by means of $(LREF allocatorObject)) only once, at client level.</p>
<p>Copyright: Andrei Alexandrescu 2013-.</p>
<p>License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).</p>
<p>Authors: $(HTTP erdani.com, Andrei Alexandrescu)</p>
<p>Source: $(PHOBOSSRC std/experimental/allocator)</p>
<h2 class='section'>Classes</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Classes/CAllocatorImpl.html">CAllocatorImpl</a></td>
<td>Implementation of <code>IAllocator</code> using <code>Allocator</code> . This adapts a statically-built allocator type to <code>IAllocator</code> that is directly usable by non-templated code.</td>
</tr>
<tr>
<td><a href="Classes/CSharedAllocatorImpl.html">CSharedAllocatorImpl</a></td>
<td>Implementation of <code>ISharedAllocator</code> using <code>Allocator</code> . This adapts a statically-built, shareable across threads, allocator type to <code>ISharedAllocator</code> that is directly usable by non-templated code.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/allocatorObject.html">allocatorObject</a></td>
<td>Returns a dynamically-typed <code>CAllocator</code> built around a given statically- typed allocator <code>a</code> of type <code>A</code> . Passing a pointer to the allocator creates a dynamic allocator around the allocator pointed to by the pointer, without attempting to copy or move it. Passing the allocator by value or reference behaves as follows.</td>
</tr>
<tr>
<td><a href="Functions/dispose.html">dispose</a></td>
<td>Destroys and then deallocates (using <code>alloc</code> ) the object pointed to by a pointer, the class object referred to by a <code>class</code> or <code>interface</code> reference, or an entire array. It is assumed the respective entities had been allocated with the same allocator.</td>
</tr>
<tr>
<td><a href="Functions/disposeMultidimensionalArray.html">disposeMultidimensionalArray</a></td>
<td>Destroys and then deallocates a multidimensional array, assuming it was created with makeMultidimensionalArray and the same allocator was used.</td>
</tr>
<tr>
<td><a href="Functions/expandArray.html">expandArray</a></td>
<td>Grows <code>array</code> by appending <code>delta</code> more elements. The needed memory is allocated using <code>alloc</code> . The extra elements added are either default- initialized, filled with copies of <code>init</code> , or initialized with values fetched from <code>range</code> .</td>
</tr>
<tr>
<td><a href="Functions/fillWithMemcpy.html">fillWithMemcpy</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/make.html">make</a></td>
<td>Dynamically allocates (using <code>alloc</code> ) and then creates in the memory allocated an object of type <code>T</code> , using <code>args</code> (if any) for its initialization. Initialization occurs in the memory allocated and is otherwise semantically the same as <code>T(args)</code> . (Note that using <code>alloc.make!(T[])</code> creates a pointer to an (empty) array of <code>T</code> s, not an array. To use an allocator to allocate and initialize an array, use <code>alloc.makeArray!T</code> described below.)</td>
</tr>
<tr>
<td><a href="Functions/makeArray.html">makeArray</a></td>
<td>Create an array of <code>T</code> with <code>length</code> elements using <code>alloc</code> . The array is either default-initialized, filled with copies of <code>init</code> , or initialized with values fetched from <code>range</code> .</td>
</tr>
<tr>
<td><a href="Functions/makeMultidimensionalArray.html">makeMultidimensionalArray</a></td>
<td>Allocates a multidimensional array of elements of type T.</td>
</tr>
<tr>
<td><a href="Functions/processAllocator.html">processAllocator</a></td>
<td>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to <code>shared</code> .</td>
</tr>
<tr>
<td><a href="Functions/setupThreadAllocator.html">setupThreadAllocator</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/sharedAllocatorObject.html">sharedAllocatorObject</a></td>
<td>Returns a dynamically-typed <code>CSharedAllocator</code> built around a given statically- typed allocator <code>a</code> of type <code>A</code> . Passing a pointer to the allocator creates a dynamic allocator around the allocator pointed to by the pointer, without attempting to copy or move it. Passing the allocator by value or reference behaves as follows.</td>
</tr>
<tr>
<td><a href="Functions/shrinkArray.html">shrinkArray</a></td>
<td>Shrinks an array by <code>delta</code> elements.</td>
</tr>
<tr>
<td><a href="Functions/theAllocator.html">theAllocator</a></td>
<td>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use <code>processAllocator</code> (below). By default, <code>theAllocator</code> ultimately fetches memory from <code>processAllocator</code> , which in turn uses the garbage collected heap.</td>
</tr>
<tr>
<td><a href="Functions/uninitializedFillDefault.html">uninitializedFillDefault</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Interfaces</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Interfaces/IAllocator.html">IAllocator</a></td>
<td>Dynamic allocator interface. Code that defines allocators ultimately implements this interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</td>
</tr>
<tr>
<td><a href="Interfaces/ISharedAllocator.html">ISharedAllocator</a></td>
<td>Dynamic shared allocator interface. Code that defines allocators shareable across threads ultimately implements this interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/EmbeddedTree.html">EmbeddedTree</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ForcedInputRange.html">ForcedInputRange</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/InternalPointersTree.html">InternalPointersTree</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/RCIAllocator.html">RCIAllocator</a></td>
<td>A reference counted struct that wraps the dynamic allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</td>
</tr>
<tr>
<td><a href="Structs/RCISharedAllocator.html">RCISharedAllocator</a></td>
<td>A reference counted struct that wraps the dynamic shared allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</td>
</tr>
<tr>
<td><a href="Structs/ThreadLocal.html">ThreadLocal</a></td>
<td>Stores an allocator object in thread-local storage (i.e. non-<code>shared</code> D global). <code>ThreadLocal!A</code> is a subtype of <code>A</code> so it appears to implement <code>A</code> 's allocator primitives.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/canSafelyDeallocPostRewind.html">canSafelyDeallocPostRewind</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/hasPureDtor.html">hasPureDtor</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/hasPurePostblit.html">hasPurePostblit</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
