<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.range | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.range | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.range.Overview">
<h1 class='section'>Module - std.range</h1><h2 class='section'>About</h2><p>This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see $(MREF std, algorithm)) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as $(REF find, std, algorithm, searching) works not just for arrays, but for linked-lists, input files, incoming network data, etc.</p>
<h3 class='section'>Guides</h3><h3 class='section'>There are many articles available that can bolster understanding ranges</h3><p>$(UL $(LI Ali Çehreli's $(HTTP ddili.org/ders/d.en/ranges.html, tutorial on ranges) for the basics of working with and creating range-based code.) $(LI Jonathan M. Davis $(LINK2 <a href="http://dconf.org/2015/talks/davis.html">http://dconf.org/2015/talks/davis.html</a>, $(I Introduction to Ranges)) talk at DConf 2015 a vivid introduction from its core constructs to practical advice.) $(LI The DLang Tour's $(LINK2 <a href="http://tour.dlang.org/tour/en/basics/ranges">http://tour.dlang.org/tour/en/basics/ranges</a>, chapter on ranges) for an interactive introduction.) $(LI H. S. Teoh's $(LINK2 <a href="http://wiki.dlang.org/Component_programming_with_ranges">http://wiki.dlang.org/Component_programming_with_ranges</a>, tutorial on component programming with ranges) for a real-world showcase of the influence of range-based programming on complex algorithms.) $(LI Andrei Alexandrescu's article <span class="math">\((LINK2 http://www.informit.com/articles/printerfriendly.aspx?p=1407357\)</span>(AMP)rll=1, $(I On Iteration)) for conceptual aspect of ranges and the motivation ) )</p>
<h3 class='section'>Submodules</h3><h3 class='section'>This module has two submodules</h3><p>The $(MREF std, range, primitives) submodule provides basic range functionality. It defines several templates for testing whether a given object is a range, what kind of range it is, and provides some common range operations.</p>
<p>The $(MREF std, range, interfaces) submodule provides object-based interfaces for working with ranges via runtime polymorphism.</p>
<p>The remainder of this module provides a rich set of range creation and composition templates that let you construct new ranges out of existing ranges:</p>
<p>$(SCRIPT inhibitQuickIndex = 1;) $(DIVC quickindex, $(BOOKTABLE , $(TR $(TD $(LREF chain)) $(TD Concatenates several ranges into a single range. )) $(TR $(TD $(LREF choose)) $(TD Chooses one of two ranges at runtime based on a boolean condition. )) $(TR $(TD $(LREF chooseAmong)) $(TD Chooses one of several ranges at runtime based on an index. )) $(TR $(TD $(LREF chunks)) $(TD Creates a range that returns fixed-size chunks of the original range. )) $(TR $(TD $(LREF cycle)) $(TD Creates an infinite range that repeats the given forward range indefinitely. Good for implementing circular buffers. )) $(TR $(TD $(LREF drop)) $(TD Creates the range that results from discarding the first $(I n) elements from the given range. )) $(TR $(TD $(LREF dropBack)) $(TD Creates the range that results from discarding the last $(I n) elements from the given range. )) $(TR $(TD $(LREF dropExactly)) $(TD Creates the range that results from discarding exactly $(I n) of the first elements from the given range. )) $(TR $(TD $(LREF dropBackExactly)) $(TD Creates the range that results from discarding exactly $(I n) of the last elements from the given range. )) $(TR $(TD $(LREF dropOne)) $(TD Creates the range that results from discarding the first element from the given range. )) $(TR $(TD $(D $(LREF dropBackOne))) $(TD Creates the range that results from discarding the last element from the given range. )) $(TR $(TD $(LREF enumerate)) $(TD Iterates a range with an attached index variable. )) $(TR $(TD $(LREF evenChunks)) $(TD Creates a range that returns a number of chunks of approximately equal length from the original range. )) $(TR $(TD $(LREF frontTransversal)) $(TD Creates a range that iterates over the first elements of the given ranges. )) $(TR $(TD $(LREF generate)) $(TD Creates a range by successive calls to a given function. This allows to create ranges as a single delegate. )) $(TR $(TD $(LREF indexed)) $(TD Creates a range that offers a view of a given range as though its elements were reordered according to a given range of indices. )) $(TR $(TD $(LREF iota)) $(TD Creates a range consisting of numbers between a starting point and ending point, spaced apart by a given interval. )) $(TR $(TD $(LREF lockstep)) $(TD Iterates $(I n) ranges in lockstep, for use in a <code>foreach</code> loop. Similar to <code>zip</code> , except that <code>lockstep</code> is designed especially for <code>foreach</code> loops. )) $(TR $(TD $(LREF nullSink)) $(TD An output range that discards the data it receives. )) $(TR $(TD $(LREF only)) $(TD Creates a range that iterates over the given arguments. )) $(TR $(TD $(LREF padLeft)) $(TD Pads a range to a specified length by adding a given element to the front of the range. Is lazy if the range has a known length. )) $(TR $(TD $(LREF padRight)) $(TD Lazily pads a range to a specified length by adding a given element to the back of the range. )) $(TR $(TD $(LREF radial)) $(TD Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point. )) $(TR $(TD $(LREF recurrence)) $(TD Creates a forward range whose values are defined by a mathematical recurrence relation. )) $(TR $(TD $(LREF refRange)) $(TD Pass a range by reference. Both the original range and the RefRange will always have the exact same elements. Any operation done on one will affect the other. )) $(TR $(TD $(LREF repeat)) $(TD Creates a range that consists of a single element repeated $(I n) times, or an infinite range repeating that element indefinitely. )) $(TR $(TD $(LREF retro)) $(TD Iterates a bidirectional range backwards. )) $(TR $(TD $(LREF roundRobin)) $(TD Given $(I n) ranges, creates a new range that return the $(I n) first elements of each range, in turn, then the second element of each range, and so on, in a round-robin fashion. )) $(TR $(TD $(LREF sequence)) $(TD Similar to <code>recurrence</code> , except that a random-access range is created. )) $(TR $(TD $(D $(LREF slide))) $(TD Creates a range that returns a fixed-size sliding window over the original range. Unlike chunks, it advances a configurable number of items at a time, not one chunk at a time. )) $(TR $(TD $(LREF stride)) $(TD Iterates a range with stride $(I n). )) $(TR $(TD $(LREF tail)) $(TD Return a range advanced to within <code>n</code> elements of the end of the given range. )) $(TR $(TD $(LREF take)) $(TD Creates a sub-range consisting of only up to the first $(I n) elements of the given range. )) $(TR $(TD $(LREF takeExactly)) $(TD Like <code>take</code> , but assumes the given range actually has $(I n) elements, and therefore also defines the <code>length</code> property. )) $(TR $(TD $(LREF takeNone)) $(TD Creates a random-access range consisting of zero elements of the given range. )) $(TR $(TD $(LREF takeOne)) $(TD Creates a random-access range consisting of exactly the first element of the given range. )) $(TR $(TD $(LREF tee)) $(TD Creates a range that wraps a given range, forwarding along its elements while also calling a provided function with each element. )) $(TR $(TD $(LREF transposed)) $(TD Transposes a range of ranges. )) $(TR $(TD $(LREF transversal)) $(TD Creates a range that iterates over the $(I n)'th elements of the given random-access ranges. )) $(TR $(TD $(LREF zip)) $(TD Given $(I n) ranges, creates a range that successively returns a tuple of all the first elements, a tuple of all the second elements, etc. )) ))</p>
<h3 class='section'>Sortedness</h3><p>Ranges whose elements are sorted afford better efficiency with certain operations. For this, the $(LREF assumeSorted) function can be used to construct a $(LREF SortedRange) from a pre-sorted range. The $(REF sort, std, algorithm, sorting) function also conveniently returns a $(LREF SortedRange). $(LREF SortedRange) objects provide some additional range operations that take advantage of the fact that the range is sorted.</p>
<p>Source: $(PHOBOSSRC std/range/package.d)</p>
<p>License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).</p>
<p>Authors: $(HTTP erdani.com, Andrei Alexandrescu), David Simcha, $(HTTP jmdavisprog.com, Jonathan M Davis), and Jack Stouffer. Credit for some of the ideas in building this module goes to $(HTTP fantascienza.net/leonardo/so/, Leonardo Maffi).</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/Cycle.html">Cycle</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/lengthType.html">lengthType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Lockstep.html">Lockstep</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/SortedRange.html">SortedRange</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/Take.html">Take</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/ZipShortest.html">ZipShortest</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Enums/SearchPolicy.html">SearchPolicy</a></td>
<td>Policy used with the searching primitives <code>lowerBound</code> , $(D upperBound), and <code>equalRange</code> of $(LREF SortedRange) below.</td>
</tr>
<tr>
<td><a href="Enums/SortedRangeOptions.html">SortedRangeOptions</a></td>
<td>Options for $(LREF SortedRange) ranges (below).</td>
</tr>
<tr>
<td><a href="Enums/StoppingPolicy.html">StoppingPolicy</a></td>
<td>Dictates how iteration in a $(LREF zip) and $(LREF lockstep) should stop. By default stop at the end of the shortest of all ranges.</td>
</tr>
<tr>
<td><a href="Enums/TransverseOptions.html">TransverseOptions</a></td>
<td>Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges (below).</td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/assumeSorted.html">assumeSorted</a></td>
<td>Assumes <code>r</code> is sorted by predicate <code>pred</code> and returns the corresponding $(D SortedRange!(pred, R)) having <code>r</code> as support. To check for sorted-ness at cost $(BIGOH n), use $(REF isSorted, std,algorithm,sorting).</td>
</tr>
<tr>
<td><a href="Functions/bitwise.html">bitwise</a></td>
<td>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</td>
</tr>
<tr>
<td><a href="Functions/chain.html">chain</a></td>
<td>Spans multiple ranges in sequence. The function <code>chain</code> takes any number of ranges and returns a $(D Chain!(R1, R2,...)) object. The ranges may be different, but they must have the same element type. The result is a range that offers the <code>front</code> , <code>popFront</code> , and $(D empty) primitives. If all input ranges offer random access and $(D length), <code>Chain</code> offers them as well.</td>
</tr>
<tr>
<td><a href="Functions/choose.html">choose</a></td>
<td>Choose one of two ranges at runtime depending on a Boolean condition.</td>
</tr>
<tr>
<td><a href="Functions/chooseAmong.html">chooseAmong</a></td>
<td>Choose one of multiple ranges at runtime.</td>
</tr>
<tr>
<td><a href="Functions/chunks.html">chunks</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/cycle.html">cycle</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/drop.html">drop</a></td>
<td>Convenience function which calls $(REF popFrontN, std, range, primitives)<code>(range, n)</code> and returns <code>range</code> . <code>drop</code> makes it easier to pop elements from a range and then pass it to another function within a single expression, whereas <code>popFrontN</code> would require multiple statements.</td>
</tr>
<tr>
<td><a href="Functions/dropBack.html">dropBack</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/dropBackExactly.html">dropBackExactly</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/dropBackOne.html">dropBackOne</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/dropExactly.html">dropExactly</a></td>
<td>Similar to $(LREF drop) and <code>dropBack</code> but they call <span class="math">\((D range.\)</span>(LREF popFrontExactly)(n)) and <code>range.popBackExactly(n)</code> instead.</td>
</tr>
<tr>
<td><a href="Functions/dropOne.html">dropOne</a></td>
<td>Convenience function which calls <code>range.popFront()</code> and returns <code>range</code> . <code>dropOne</code> makes it easier to pop an element from a range and then pass it to another function within a single expression, whereas <code>popFront</code> would require multiple statements.</td>
</tr>
<tr>
<td><a href="Functions/enumerate.html">enumerate</a></td>
<td>Iterate over <code>range</code> with an attached index variable.</td>
</tr>
<tr>
<td><a href="Functions/evenChunks.html">evenChunks</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/frontTransversal.html">frontTransversal</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/generate.html">generate</a></td>
<td>Given callable (<span class="math">\((REF isCallable, std,traits)) `fun` , create as a range whose front is defined by successive calls to `fun()` . This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire `front` /`popFront`/`empty` structure. `fun` maybe be passed either a template alias parameter (existing function, delegate, struct type defining `static opCall` ) or a run-time value argument (delegate, function object). The result range models an InputRange (\)</span>(REF isInputRange, std,range,primitives)). The resulting range will call <code>fun()</code> on construction, and every call to <code>popFront</code> , and the cached value will be returned when <code>front</code> is called.</td>
</tr>
<tr>
<td><a href="Functions/indexed.html">indexed</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/iota.html">iota</a></td>
<td>Creates a range of values that span the given starting and stopping values.</td>
</tr>
<tr>
<td><a href="Functions/lockstep.html">lockstep</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/lockstepReverseFailMixin.html">lockstepReverseFailMixin</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/nullSink.html">nullSink</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/only.html">only</a></td>
<td>Assemble <code>values</code> into a range that carries all its elements in-situ.</td>
</tr>
<tr>
<td><a href="Functions/padLeft.html">padLeft</a></td>
<td>Extends the length of the input range <code>r</code> by padding out the start of the range with the element <code>e</code> . The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by $(REF CommonType, std, traits). If <code>n</code> is less than the length of of <code>r</code> , then <code>r</code> is returned unmodified.</td>
</tr>
<tr>
<td><a href="Functions/padRight.html">padRight</a></td>
<td>Extend the length of the input range <code>r</code> by padding out the end of the range with the element <code>e</code> . The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by $(REF CommonType, std, traits). If <code>n</code> is less than the length of of <code>r</code> , then the contents of <code>r</code> are returned.</td>
</tr>
<tr>
<td><a href="Functions/radial.html">radial</a></td>
<td>Iterates a random-access range starting from a given point and progressively extending left and right from that point. If no initial point is given, iteration starts from the middle of the range. Iteration spans the entire range.</td>
</tr>
<tr>
<td><a href="Functions/recurrence.html">recurrence</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/refRange.html">refRange</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/repeat.html">repeat</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/retro.html">retro</a></td>
<td>Iterates a bidirectional range backwards. The original range can be accessed by using the <code>source</code> property. Applying retro twice to the same range yields the original range.</td>
</tr>
<tr>
<td><a href="Functions/roundRobin.html">roundRobin</a></td>
<td>$(D roundRobin(r1, r2, r3)) yields <code>r1.front</code> , then <code>r2.front</code> , then <code>r3.front</code> , after which it pops off one element from each and continues again from <code>r1</code> . For example, if two ranges are involved, it alternately yields elements off the two ranges. <code>roundRobin</code> stops after it has consumed all ranges (skipping over the ones that finish early).</td>
</tr>
<tr>
<td><a href="Functions/sequence.html">sequence</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/slide.html">slide</a></td>
<td>A fixed-sized sliding window iteration of size <code>windowSize</code> over a <code>source</code> range by a custom <code>stepSize</code> .</td>
</tr>
<tr>
<td><a href="Functions/stride.html">stride</a></td>
<td>Iterates range <code>r</code> with stride <code>n</code> . If the range is a random-access range, moves by indexing into the range; otherwise, moves by successive calls to <code>popFront</code> . Applying stride twice to the same range results in a stride with a step that is the product of the two applications. It is an error for <code>n</code> to be 0.</td>
</tr>
<tr>
<td><a href="Functions/tail.html">tail</a></td>
<td>Return a range advanced to within <code>_n</code> elements of the end of <code>range</code> .</td>
</tr>
<tr>
<td><a href="Functions/take.html">take</a></td>
<td>Lazily takes only up to <code>n</code> elements of a range. This is particularly useful when using with infinite ranges.</td>
</tr>
<tr>
<td><a href="Functions/takeExactly.html">takeExactly</a></td>
<td>Similar to $(LREF take), but assumes that <code>range</code> has at least $(D n) elements. Consequently, the result of $(D takeExactly(range, n)) always defines the <code>length</code> property (and initializes it to <code>n</code> ) even when <code>range</code> itself does not define <code>length</code> .</td>
</tr>
<tr>
<td><a href="Functions/takeNone.html">takeNone</a></td>
<td>Returns an empty range which is statically known to be empty and is guaranteed to have <code>length</code> and be random access regardless of <code>R</code> 's capabilities.</td>
</tr>
<tr>
<td><a href="Functions/takeOne.html">takeOne</a></td>
<td>Returns a range with at most one element; for example, $(D takeOne([42, 43, 44])) returns a range consisting of the integer $(D 42). Calling <code>popFront()</code> off that range renders it empty.</td>
</tr>
<tr>
<td><a href="Functions/tee.html">tee</a></td>
<td>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or $(LREF OutputRange) as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to <code>front</code> or <code>popFront</code> , or diverting the elements of a range into an auxiliary $(LREF OutputRange).</td>
</tr>
<tr>
<td><a href="Functions/transposed.html">transposed</a></td>
<td>Given a range of ranges, returns a range of ranges where the $(I i)'th subrange contains the $(I i)'th elements of the original subranges.</td>
</tr>
<tr>
<td><a href="Functions/transversal.html">transversal</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Functions/zip.html">zip</a></td>
<td>Ditto</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/Bitwise.html">Bitwise</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ChooseResult.html">ChooseResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Chunks.html">Chunks</a></td>
<td>This range iterates over fixed-sized chunks of size <code>chunkSize</code> of a <code>source</code> range. <code>Source</code> must be an $(REF_ALTTEXT input range, isInputRange, std,range,primitives). <code>chunkSize</code> must be greater than zero.</td>
</tr>
<tr>
<td><a href="Structs/Cycle.html">Cycle</a></td>
<td>Repeats the given forward range ad infinitum. If the original range is infinite (fact that would make <code>Cycle</code> the identity application), <code>Cycle</code> detects that and aliases itself to the range type itself. That works for non-forward ranges too. If the original range has random access, <code>Cycle</code> offers random access and also offers a constructor taking an initial position <code>index</code> . <code>Cycle</code> works with static arrays in addition to ranges, mostly for performance reasons.</td>
</tr>
<tr>
<td><a href="Structs/Cycle.html">Cycle</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Structs/EvenChunks.html">EvenChunks</a></td>
<td>This range splits a <code>source</code> range into <code>chunkCount</code> chunks of approximately equal length. <code>Source</code> must be a forward range with known length.</td>
</tr>
<tr>
<td><a href="Structs/FrontTransversal.html">FrontTransversal</a></td>
<td>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</td>
</tr>
<tr>
<td><a href="Structs/Generator.html">Generator</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Indexed.html">Indexed</a></td>
<td>This struct takes two ranges, <code>source</code> and <code>indices</code> , and creates a view of <code>source</code> as if its elements were reordered according to <code>indices</code> . <code>indices</code> may include only a subset of the elements of <code>source</code> and may also repeat elements.</td>
</tr>
<tr>
<td><a href="Structs/Lockstep.html">Lockstep</a></td>
<td>Iterate multiple ranges in lockstep using a <code>foreach</code> loop. In contrast to $(LREF zip) it allows reference access to its elements. If only a single range is passed in, the <code>Lockstep</code> aliases itself away.  If the ranges are of different lengths and <code>s</code> == <code>StoppingPolicy.shortest</code> stop after the shortest range is empty.  If the ranges are of different lengths and <code>s</code> == <code>StoppingPolicy.requireSameLength</code> , throw an exception.  <code>s</code> may not be <code>StoppingPolicy.longest</code> , and passing this will throw an exception.</td>
</tr>
<tr>
<td><a href="Structs/LockstepMixin.html">LockstepMixin</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/NullSink.html">NullSink</a></td>
<td>An OutputRange that discards the data it receives.</td>
</tr>
<tr>
<td><a href="Structs/OnlyResult.html">OnlyResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/OnlyResult.html">OnlyResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Recurrence.html">Recurrence</a></td>
<td>Creates a mathematical sequence given the initial values and a recurrence function that computes the next value from the existing values. The sequence comes in the form of an infinite forward range. The type <code>Recurrence</code> itself is seldom used directly; most often, recurrences are obtained by calling the function $(D recurrence).</td>
</tr>
<tr>
<td><a href="Structs/RefRange.html">RefRange</a></td>
<td>Wrapper which effectively makes it possible to pass a range by reference. Both the original range and the RefRange will always have the exact same elements. Any operation done on one will affect the other. So, for instance, if it's passed to a function which would implicitly copy the original range if it were passed to it, the original range is $(I not) copied but is consumed as if it were a reference type.</td>
</tr>
<tr>
<td><a href="Structs/Repeat.html">Repeat</a></td>
<td>Create a range which repeats one value.</td>
</tr>
<tr>
<td><a href="Structs/Sequence.html">Sequence</a></td>
<td><code>Sequence</code> is similar to <code>Recurrence</code> except that iteration is presented in the so-called $(HTTP en.wikipedia.org/wiki/Closed_form, closed form). This means that the <code>n</code> th element in the series is computable directly from the initial values and <code>n</code> itself. This implies that the interface offered by <code>Sequence</code> is a random-access range, as opposed to the regular <code>Recurrence</code> , which only offers forward iteration.</td>
</tr>
<tr>
<td><a href="Structs/Slides.html">Slides</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/SortedRange.html">SortedRange</a></td>
<td>Represents a sorted range. In addition to the regular range primitives, supports additional operations that take advantage of the ordering, such as merge and binary search. To obtain a $(D SortedRange) from an unsorted range <code>r</code> , use $(REF sort, std,algorithm,sorting) which sorts <code>r</code> in place and returns the corresponding <code>SortedRange</code> . To construct a <code>SortedRange</code> from a range <code>r</code> that is known to be already sorted, use $(LREF assumeSorted).</td>
</tr>
<tr>
<td><a href="Structs/Take.html">Take</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Structs/Transposed.html">Transposed</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Transversal.html">Transversal</a></td>
<td>Given a range of ranges, iterate transversally through the <code>n</code> th element of each of the enclosed ranges. This function is similar to <code>unzip</code> in other languages.</td>
</tr>
<tr>
<td><a href="Structs/Zip.html">Zip</a></td>
<td>Iterate several ranges in lockstep. The element type is a proxy tuple that allows accessing the current element in the <code>n</code> th range by using <code>e[n]</code> .</td>
</tr>
<tr>
<td><a href="Structs/ZipShortest.html">ZipShortest</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/isSomeFiniteCharInputRange.html">isSomeFiniteCharInputRange</a></td>
<td>This simplifies a commonly used idiom in phobos for accepting any kind of string parameter. The type <code>R</code> can for example be a simple string, chained string using $(REF chain, std,range), $(REF chainPath, std,path) or any other input range of characters.</td>
</tr>
<tr>
<td><a href="Variables/isTwoWayCompatible.html">isTwoWayCompatible</a></td>
<td>Returns true if <code>fn</code> accepts variables of type T1 and T2 in any order. The following code should compile: --- (ref T1 a, ref T2 b) { fn(a, b); fn(b, a); } ---</td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
