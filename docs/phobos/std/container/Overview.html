<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.container | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.container | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.container.Overview">
<h1 class='section'>Module - std.container</h1><h2 class='section'>About</h2><p>This module defines generic containers.</p>
<h3 class='section'>Construction</h3><p>To implement the different containers both struct and class based approaches have been used. $(REF make, std,container,util) allows for uniform construction with either approach.</p>
<p>--- import std.container; // Construct a red-black tree and an array both containing the values 1, 2, 3. // RedBlackTree should typically be allocated using <code>new</code> RedBlackTree!int rbTree = new RedBlackTree!int(1, 2, 3); // But <code>new</code> should not be used with Array Array!int array = Array!int(1, 2, 3); // <code>make</code> hides the differences RedBlackTree!int rbTree2 = make!(RedBlackTree!int)(1, 2, 3); Array!int array2 = make!(Array!int)(1, 2, 3); ---</p>
<p>Note that <code>make</code> can infer the element type from the given arguments.</p>
<p>--- import std.container; auto rbTree = make!RedBlackTree(1, 2, 3); // RedBlackTree!int auto array = make!Array(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); // Array!string ---</p>
<h3 class='section'>Reference_semantics</h3><p>All containers have reference semantics, which means that after assignment both variables refer to the same underlying data.</p>
<p>To make a copy of a container, use the <code>c.dup</code> container primitive. --- import std.container, std.range; Array!int originalArray = make!(Array!int)(1, 2, 3); Array!int secondArray = originalArray; assert(equal(originalArray[], secondArray[]));</p>
<p>// changing one instance changes the other one as well! originalArray[0] = 12; assert(secondArray[0] == 12);</p>
<p>// secondArray now refers to an independent copy of originalArray secondArray = originalArray.dup; secondArray[0] = 1; // assert that originalArray has not been affected assert(originalArray[0] == 12); ---</p>
<p>$(B Attention:) If the container is implemented as a class, using an uninitialized instance can cause a null pointer dereference.</p>
<p>--- import std.container;</p>
<p>RedBlackTree!int rbTree; rbTree.insert(5); // null pointer dereference ---</p>
<p>Using an uninitialized struct-based container will work, because the struct intializes itself upon use; however, up to this point the container will not have an identity and assignment does not create two references to the same data.</p>
<p>--- import std.container;</p>
<p>// create an uninitialized array Array!int array1; // array2 does <em>not</em> refer to array1 Array!int array2 = array1; array2.insertBack(42); // thus array1 will not be affected assert(array1.empty);</p>
<p>// after initialization reference semantics work as expected array1 = array2; // now affects array2 as well array1.removeBack(); assert(array2.empty); --- It is therefore recommended to always construct containers using $(REF make, std,container,util).</p>
<p>This is in fact necessary to put containers into another container. For example, to construct an <code>Array</code> of ten empty <code>Array</code> s, use the following that calls <code>make</code> ten times.</p>
<p>--- import std.container, std.range;</p>
<p>auto arrOfArrs = make!Array(generate!(() =&gt; make!(Array!int)).take(10)); ---</p>
<h3 class='section'>Submodules</h3><h3 class='section'>This module consists of the following submodules</h3><p>$(UL $(LI The $(MREF std, container, array) module provides an array type with deterministic control of memory, not reliant on the GC unlike built-in arrays. ) $(LI The $(MREF std, container, binaryheap) module provides a binary heap implementation that can be applied to any user-provided random-access range. ) $(LI The $(MREF std, container, dlist) module provides a doubly-linked list implementation. ) $(LI The $(MREF std, container, rbtree) module implements red-black trees. ) $(LI The $(MREF std, container, slist) module implements singly-linked lists. ) $(LI The $(MREF std, container, util) module contains some generic tools commonly used by container implementations. ) )</p>
<h3 class='section'>The_primary_range_of_a_container</h3><p>While some containers offer direct access to their elements e.g. via <code>opIndex</code> , <code>c.front</code> or <code>c.back</code> , access and modification of a container's contents is generally done through its primary $(MREF_ALTTEXT range, std, range) type, which is aliased as <code>C.Range</code> . For example, the primary range type of <code>Array!int</code> is <code>Array!int.Range</code> .</p>
<p>If the documentation of a member function of a container takes a parameter of type <code>Range</code> , then it refers to the primary range type of this container. Oftentimes <code>Take!Range</code> will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters $(B must) be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</p>
<p>--- import std.algorithm.comparison : equal; import std.algorithm.iteration : find; import std.container; import std.range : take;</p>
<p>auto array = make!Array(1, 2, 3);</p>
<p>// <code>find</code> returns an Array!int.Range advanced to the element &quot;2&quot; array.linearRemove(array[].find(2));</p>
<p>assert(array[].equal([1]));</p>
<p>array = make!Array(1, 2, 3);</p>
<p>// the range given to <code>linearRemove</code> is a Take!(Array!int.Range) // spanning just the element &quot;2&quot; array.linearRemove(array[].find(2).take(1));</p>
<p>assert(array[].equal([1, 3])); ---</p>
<p>When any $(MREF_ALTTEXT range, std, range) can be passed as an argument to a member function, the documention usually refers to the parameter's templated type as <code>Stuff</code> .</p>
<p>--- import std.algorithm.comparison : equal; import std.container; import std.range : iota;</p>
<p>auto array = make!Array(1, 2);</p>
<p>// the range type returned by <code>iota</code> is completely unrelated to Array, // which is fine for Array.insertBack: array.insertBack(iota(3, 10));</p>
<p>assert(array[].equal([1, 2, 3, 4, 5, 6, 7, 8, 9])); ---</p>
<h3 class='section'>Container_primitives</h3><p>Containers do not form a class hierarchy, instead they implement a common set of primitives (see table below). These primitives each guarantee a specific worst case complexity and thus allow generic code to be written independently of the container implementation.</p>
<p>For example the primitives <code>c.remove(r)</code> and <code>c.linearRemove(r)</code> both remove the sequence of elements in range <code>r</code> from the container <code>c</code> . The primitive <code>c.remove(r)</code> guarantees <span class="math">\((BIGOH n\)</span>(SUBSCRIPT r) log n$(SUBSCRIPT c)) complexity in the worst case and <code>c.linearRemove(r)</code> relaxes this guarantee to <span class="math">\((BIGOH n\)</span>(SUBSCRIPT c)).</p>
<p>Since a sequence of elements can be removed from a $(MREF_ALTTEXT doubly linked list,std,container,dlist) in constant time, <code>DList</code> provides the primitive <code>c.remove(r)</code> as well as <code>c.linearRemove(r)</code> . On the other hand $(MREF_ALTTEXT Array, std,container, array) only offers <code>c.linearRemove(r)</code> .</p>
<p>The following table describes the common set of primitives that containers implement.  A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the $(B syntax) column with the semantics described in the $(B description) column, and it must not have a worst-case complexity worse than denoted in big-O notation in the $(BIGOH ·) column.  Below, <code>C</code> means a container type, <code>c</code> is a value of container type, <span class="math">\((D n\)</span>(SUBSCRIPT x)) represents the effective length of value <code>x</code> , which could be a single element (in which case <span class="math">\((D n\)</span>(SUBSCRIPT x)) is <code>1</code> ), a container, or a range.</p>
<p>$(BOOKTABLE Container primitives, $(TR $(TH Syntax) $(TH $(BIGOH ·)) $(TH Description) ) $(TR $(TDNW <code>C(x)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT x))) $(TD Creates a container of type <code>C</code> from either another container or a range. The created container must not be a null reference even if x is empty.) ) $(TR $(TDNW <code>c.dup</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Returns a duplicate of the container.) ) $(TR $(TDNW $(D c ~ x)) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD Returns the concatenation of <code>c</code> and <code>r</code> . <code>x</code> may be a single element or an input range.) ) $(TR $(TDNW $(D x ~ c)) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD Returns the concatenation of <code>x</code> and <code>c</code> .  <code>x</code> may be a single element or an input range type.) ) $(LEADINGROWN 3, Iteration ) $(TR $(TD <code>c.Range</code> ) $(TD) $(TD The primary range type associated with the container.) ) $(TR $(TD <code>c[]</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns a range iterating over the entire container, in a container-defined order.) ) $(TR $(TDNW $(D c[a .. b])) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Fetches a portion of the container from key <code>a</code> to key <code>b</code> .) ) $(LEADINGROWN 3, Capacity ) $(TR $(TD <code>c.empty</code> ) $(TD <code>1</code> ) $(TD Returns <code>true</code> if the container has no elements, <code>false</code> otherwise.) ) $(TR $(TD <code>c.length</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns the number of elements in the container.) ) $(TR $(TDNW $(D c.length = n)) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c) + n)) $(TD Forces the number of elements in the container to <code>n</code> . If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with <code>T.init</code> ).) ) $(TR $(TD <code>c.capacity</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns the maximum number of elements that can be stored in the container without triggering a reallocation.) ) $(TR $(TD <code>c.reserve(x)</code> ) $(TD <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Forces <code>capacity</code> to at least <code>x</code> without reducing it.) ) $(LEADINGROWN 3, Access ) $(TR $(TDNW <code>c.front</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns the first element of the container, in a container-defined order.) ) $(TR $(TDNW <code>c.moveFront</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Destructively reads and returns the first element of the container. The slot is not removed from the container; it is left initialized with <code>T.init</code> . This routine need not be defined if $(D front) returns a <code>ref</code> .) ) $(TR $(TDNW $(D c.front = v)) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Assigns <code>v</code> to the first element of the container.) ) $(TR $(TDNW <code>c.back</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns the last element of the container, in a container-defined order.) ) $(TR $(TDNW <code>c.moveBack</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Destructively reads and returns the last element of the container. The slot is not removed from the container; it is left initialized with <code>T.init</code> . This routine need not be defined if $(D front) returns a <code>ref</code> .) ) $(TR $(TDNW $(D c.back = v)) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Assigns <code>v</code> to the last element of the container.) ) $(TR $(TDNW <code>c[x]</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Provides indexed access into the container. The index type is container-defined. A container may define several index types (and consequently overloaded indexing).) ) $(TR $(TDNW <code>c.moveAt(x)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Destructively reads and returns the value at position <code>x</code> . The slot is not removed from the container; it is left initialized with $(D T.init).) ) $(TR $(TDNW $(D c[x] = v)) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Sets element at specified index into the container.) ) $(TR $(TDNW $(D c[x] $(I op)= v)) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Performs read-modify-write operation at specified index into the container.) ) $(LEADINGROWN 3, Operations ) $(TR $(TDNW $(D e in c)) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns nonzero if e is found in <code>c</code> .) ) $(TR $(TDNW <code>c.lowerBound(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns a range of all elements strictly less than <code>v</code> .) ) $(TR $(TDNW <code>c.upperBound(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns a range of all elements strictly greater than <code>v</code> .) ) $(TR $(TDNW <code>c.equalRange(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Returns a range of all elements in <code>c</code> that are equal to <code>v</code> .) ) $(LEADINGROWN 3, Modifiers ) $(TR $(TDNW $(D c ~= x)) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD Appends <code>x</code> to <code>c</code> . <code>x</code> may be a single element or an input range type.) ) $(TR $(TDNW <code>c.clear()</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Removes all elements in <code>c</code> .) ) $(TR $(TDNW <code>c.insert(x)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT x) log n$(SUBSCRIPT c))) $(TD Inserts <code>x</code> in <code>c</code> at a position (or positions) chosen by <code>c</code> .) ) $(TR $(TDNW <code>c.stableInsert(x)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT x) log n$(SUBSCRIPT c))) $(TD Same as <code>c.insert(x)</code> , but is guaranteed to not invalidate any ranges.) ) $(TR $(TDNW <code>c.linearInsert(v)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.insert(v)</code> but relaxes complexity to linear.) ) $(TR $(TDNW <code>c.stableLinearInsert(v)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.stableInsert(v)</code> but relaxes complexity to linear.) ) $(TR $(TDNW <code>c.removeAny()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Removes some element from <code>c</code> and returns it.) ) $(TR $(TDNW <code>c.stableRemoveAny()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.removeAny()</code> , but is guaranteed to not invalidate any iterators.) ) $(TR $(TDNW <code>c.insertFront(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Inserts <code>v</code> at the front of <code>c</code> .) ) $(TR $(TDNW <code>c.stableInsertFront(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.insertFront(v)</code> , but guarantees no ranges will be invalidated.) ) $(TR $(TDNW <code>c.insertBack(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Inserts <code>v</code> at the back of <code>c</code> .) ) $(TR $(TDNW <code>c.stableInsertBack(v)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.insertBack(v)</code> , but guarantees no ranges will be invalidated.) ) $(TR $(TDNW <code>c.removeFront()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Removes the element at the front of <code>c</code> .) ) $(TR $(TDNW <code>c.stableRemoveFront()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.removeFront()</code> , but guarantees no ranges will be invalidated.) ) $(TR $(TDNW <code>c.removeBack()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Removes the value at the back of <code>c</code> .) ) $(TR $(TDNW <code>c.stableRemoveBack()</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.removeBack()</code> , but guarantees no ranges will be invalidated.) ) $(TR $(TDNW <code>c.remove(r)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT r) log n$(SUBSCRIPT c))) $(TD Removes range <code>r</code> from <code>c</code> .) ) $(TR $(TDNW <code>c.stableRemove(r)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT r) log n$(SUBSCRIPT c))) $(TD Same as <code>c.remove(r)</code> , but guarantees iterators are not invalidated.) ) $(TR $(TDNW <code>c.linearRemove(r)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Removes range <code>r</code> from <code>c</code> .) ) $(TR $(TDNW <code>c.stableLinearRemove(r)</code> ) $(TDNW <span class="math">\((D n\)</span>(SUBSCRIPT c))) $(TD Same as <code>c.linearRemove(r)</code> , but guarantees iterators are not invalidated.) ) $(TR $(TDNW <code>c.removeKey(k)</code> ) $(TDNW <span class="math">\((D log n\)</span>(SUBSCRIPT c))) $(TD Removes an element from <code>c</code> by using its key <code>k</code> . The key's type is defined by the container.) ) )</p>
<p>Source: $(PHOBOSSRC std/container/package.d)</p>
<p>Copyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code copyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.</p>
<p>License: Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at $(HTTP boost.org/LICENSE_1_0.txt)).</p>
<p>Authors: Steven Schveighoffer, $(HTTP erdani.com, Andrei Alexandrescu)</p>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/TotalContainer.html">TotalContainer</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
