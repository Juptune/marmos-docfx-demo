<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Struct - File | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Struct - File | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.stdio.Structs.File">
<h1 class='section'>Struct - File</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.stdio</dd></dl>
</div><pre><code class='lang-d'>public struct File
{
  // Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle a chunk at a time. 
  auto byChunk( size_t chunkSize ) 
  // Ditto 
  auto byChunk( ubyte[] buffer ) 
  // Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle one line at a time. 
  auto byLine(
    Terminator = char,
    Char = char
  )(
    KeepTerminator keepTerminator = No.keepTerminator,
    Terminator terminator = &#39;\n&#39;
  ) 
  // ditto 
  auto byLine(
    Terminator,
    Char = char
  )(
    KeepTerminator keepTerminator,
    Terminator terminator
  ) 
  // Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle one line at a time. Each line will be newly allocated. `front` will cache its value to allow repeated calls without unnecessary allocations. 
  auto byLineCopy(
    Terminator = char,
    Char = char
  )(
    KeepTerminator keepTerminator = No.keepTerminator,
    Terminator terminator = &#39;\n&#39;
  ) 
  // ditto 
  auto byLineCopy(
    Terminator,
    Char = char
  )(
    KeepTerminator keepTerminator,
    Terminator terminator
  ) 
  // Creates an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to parse one line at a time from the file into a tuple. 
  auto byRecord( Fields... )( string format ) 
  // If the file is closed or not yet opened, succeeds vacuously. Otherwise, returns $(CSTDIO clearerr) for the file handle. 
  void clearerr() @safe nothrow pure
  // If the file was closed or not yet opened, succeeds vacuously. Otherwise closes the file (by calling $(CSTDIO fclose)), throwing on error. Even if an exception is thrown, afterwards the $(D File) object is empty. This is different from `detach` in that it always closes the file; consequently, all other `File` objects referring to the same handle will see a closed file henceforth. 
  void close() @trusted
  // 
  void closeHandles() @trusted
  // Detaches from the underlying file. If the sole owner, calls `close` . 
  void detach() @trusted
  // Returns `true` if the file is at end (see $(CSTDIO feof)). 
  bool eof() @property @trusted pure
  // If the file is closed or not yet opened, returns `true` . Otherwise, returns $(CSTDIO ferror) for the file handle. 
  bool error() @property @trusted nothrow pure
  // First calls `detach` (throwing on failure), then attempts to associate the given file descriptor with the `File` , and sets the file&#39;s name to `null` . 
  void fdopen( int fd, scope char[] stdioOpenmode = &quot;rb&quot; ) @safe
  // 
  void fdopen( int fd, scope char[] stdioOpenmode, string name ) @trusted
  // Returns the file number corresponding to this object. 
  fileno_t fileno() @property @trusted
  // Flushes the C `FILE` buffers. 
  void flush() @trusted
  // Returns the `FILE*` corresponding to this object. 
  FILE* getFP() @safe pure
  // 
  void initImpl(
    FILE* handle,
    string name,
    uint refs = 1,
    bool isPopened = false
  ) @nogc @safe nothrow pure
  // Returns `true` if the file is opened. 
  bool isOpen() @property @safe nothrow pure
  // Locks the specified file segment. If the file segment is already locked by another process, waits until the existing lock is released. If both `start` and `length` are zero, the entire file is locked. 
  void lock( LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0 ) 
  // 
  int lockImpl( int operation, short l_type, ulong start, ulong length ) 
  // 
  BOOL lockImpl( alias F, Flags... )( ulong start, ulong length, Flags flags ) 
  // Returns an output range that locks the file and allows fast writing to it. 
  auto lockingBinaryWriter() 
  // Output range which locks the file when created, and unlocks the file when it goes out of scope. 
  auto lockingTextWriter() @safe
  // Returns the name last used to initialize this `File` , if any. 
  ref string name() @property @safe nothrow return pure
  // Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file. 
  ref File opAssign( File rhs ) @safe return
  // Detaches from the current file (throwing on failure), and then attempts to open file `name` with mode `stdioOpenmode`. The mode has the same semantics as in the C standard library $(CSTDIO fopen) function. 
  void open( string name, scope char[] stdioOpenmode = &quot;rb&quot; ) @trusted
  // Detaches from the current file (throwing on failure), and then runs a command by calling the C standard library function $(HTTP pubs.opengroup.org/onlinepubs/7908799/xsh/popen.html, popen). 
  void popen( string command, scope char[] stdioOpenmode = &quot;r&quot; ) @safe
  // Calls $(CSTDIO fread) for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively. 
  T[] rawRead( T )( T[] buffer ) 
  // Calls $(CSTDIO fwrite) for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety. 
  void rawWrite( T )( in T[] buffer ) 
  // Reads formatted *data from the file using $(REF formattedRead, std,* format). Params: format = The $(REF_ALTTEXT format string, formattedWrite, std, format). When passed as a compile-time argument, the string will be statically checked against the argument types passed. data = Items to be read. Returns: Same as `formattedRead` : The number of variables filled. If the input range `r` ends early, this number will be less than the number of variables provided. Example: ---- // test.d void main() { import std.stdio; auto f = File(&quot;input&quot;); foreach (_; 0 .. 3) { int a; f.readf!&quot; %d&quot;(a); writeln(++a); } } ---- $(CONSOLE % echo &quot;1 2 3&quot; &gt; input % rdmd test.d 2 3 4 ) 
  uint readf( alias format, Data... )( auto ref Data data ) 
  // ditto 
  uint readf( Data... )( scope char[] format, auto ref Data data ) 
  // Read line from the file handle and return it as a specified type. 
  S readln( S = string )( dchar terminator = &#39;\n&#39; ) @safe
  // Read line from the file handle and write it to `buf[]` , including terminating character. 
  size_t readln( C )( ref C[] buf, dchar terminator = &#39;\n&#39; ) @safe
  // ditto 
  size_t readln( C, R )( ref C[] buf, R terminator ) @safe
  // Reuses the `File` object to either open a different file, or change the file mode. If `name` is `null` , the mode of the currently open file is changed; otherwise, a new file is opened, reusing the C `FILE*` . The function has the same semantics as in the C standard library $(CSTDIO freopen) function. 
  void reopen( string name, scope char[] stdioOpenmode = &quot;rb&quot; ) @trusted
  // 
  void resetFile( string name, scope char[] stdioOpenmode, bool isPopened ) @trusted
  // Calls $(CSTDIO rewind) for the file handle. 
  void rewind() @safe
  // Calls $(CSTDIO fseek) for the file handle to move its position indicator. 
  void seek( long offset, int origin = SEEK_SET ) @trusted
  // 
  void setAppendWin( scope char[] stdioOpenmode ) @safe
  // Calls $(CSTDIO setvbuf) for the file handle. 
  void setvbuf( size_t size, int mode = _IOFBF ) @trusted
  // Calls $(CSTDIO setvbuf) for the file handle. 
  void setvbuf( void[] buf, int mode = _IOFBF ) @trusted
  // Returns the size of the file in bytes, ulong.max if file is not searchable or throws if the operation fails. Example: --- import std.stdio, std.file; 
  ulong size() @property @safe
  // Forces any data buffered by the OS to be written to disk. Call $(LREF flush) before calling this function to flush the C `FILE` buffers first. 
  void sync() @trusted
  // Calls $(CSTDIO ftell) for the managed file handle, which returns the current value of the position indicator of the file handle. 
  ulong tell() @property @trusted
  // Returns a temporary file by calling $(CSTDIO tmpfile). Note that the created file has no $(LREF name). 
  File tmpfile() @safe
  // Attempts to lock the specified file segment. If both `start` and `length` are zero, the entire file is locked. Returns: `true` if the lock was successful, and `false` if the specified file segment was already locked. 
  bool tryLock( LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0 ) 
  // Removes the lock over the specified file segment. 
  void unlock( ulong start = 0, ulong length = 0 ) 
  // Returns the underlying operating system `HANDLE` (Windows only). 
  HANDLE windowsHandle() @property
  // 
  HANDLE windowsHandle() @property
  // First calls `detach` (throwing on failure), and then attempts to associate the given Windows `HANDLE` with the `File` . The mode must be compatible with the access attributes of the handle. Windows only. 
  void windowsHandleOpen( HANDLE handle, scope char[] stdioOpenmode ) 
  // 
  void windowsHandleOpen( HANDLE handle, scope char[] stdioOpenmode ) 
  // Unsafe function that wraps an existing `FILE*` . The resulting $(D File) never takes the initiative in closing the file. Note that the created file has no $(LREF name) 
  File wrapFile( FILE* f ) @safe
  // Writes its arguments in text format to the file. 
  void write( S... )( S args ) 
  // Writes its arguments in text format to the file, according to the format string fmt. 
  void writef( alias fmt, A... )( A args ) 
  // ditto 
  void writef( Char, A... )( in Char[] fmt, A args ) 
  // Equivalent to `file.writef(fmt, args, &#39;\n&#39;)` . 
  void writefln( alias fmt, A... )( A args ) 
  // ditto 
  void writefln( Char, A... )( in Char[] fmt, A args ) 
  // Writes its arguments in text format to the file, followed by a newline. 
  void writeln( S... )( S args ) 
}</code></pre><h2 class='section'>About</h2><p>Encapsulates a <code>FILE*</code> . Generally D does not attempt to provide thin wrappers over equivalent functions in the C standard library, but manipulating <code>FILE*</code> values directly is unsafe and error-prone in many ways. The <code>File</code> type ensures safe manipulation, automatic file closing, and a lot of convenience.</p>
<p>The underlying <code>FILE*</code> handle is maintained in a reference-counted manner, such that as soon as the last <code>File</code> variable bound to a given <code>FILE*</code> goes out of scope, the underlying <code>FILE*</code> is automatically closed.</p>
<h3 class='section'>Example</h3><p>---- // test.d import std.stdio;</p>
<p>void main(string[] args) { auto f = File(&quot;test.txt&quot;, &quot;w&quot;); // open for writing f.write(&quot;Hello&quot;); if (args.length &gt; 1) { auto g = f; // now g and f write to the same file // internal reference count is 2 g.write(&quot;, &quot;, args[1]); // g exits scope, reference count decreases to 1 } f.writeln(&quot;!&quot;); // f exits scope, reference count falls to zero, // underlying <code>FILE*</code> is closed. } ---- $(CONSOLE % rdmd test.d Jimmy % cat test.txt Hello, Jimmy! % )</p>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../File/File/Enums/Orientation.html">Orientation</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../File/File/Functions/byChunk.html">byChunk</a></td>
<td>Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle a chunk at a time.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/byLine.html">byLine</a></td>
<td>Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle one line at a time.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/byLineCopy.html">byLineCopy</a></td>
<td>Returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to read from the file handle one line at a time. Each line will be newly allocated. <code>front</code> will cache its value to allow repeated calls without unnecessary allocations.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/byRecord.html">byRecord</a></td>
<td>Creates an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) set up to parse one line at a time from the file into a tuple.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/clearerr.html">clearerr</a></td>
<td>If the file is closed or not yet opened, succeeds vacuously. Otherwise, returns $(CSTDIO clearerr) for the file handle.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/close.html">close</a></td>
<td>If the file was closed or not yet opened, succeeds vacuously. Otherwise closes the file (by calling $(CSTDIO fclose)), throwing on error. Even if an exception is thrown, afterwards the $(D File) object is empty. This is different from <code>detach</code> in that it always closes the file; consequently, all other <code>File</code> objects referring to the same handle will see a closed file henceforth.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/closeHandles.html">closeHandles</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Functions/detach.html">detach</a></td>
<td>Detaches from the underlying file. If the sole owner, calls <code>close</code> .</td>
</tr>
<tr>
<td><a href="../File/File/Functions/eof.html">eof</a></td>
<td>Returns <code>true</code> if the file is at end (see $(CSTDIO feof)).</td>
</tr>
<tr>
<td><a href="../File/File/Functions/error.html">error</a></td>
<td>If the file is closed or not yet opened, returns <code>true</code> . Otherwise, returns $(CSTDIO ferror) for the file handle.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/fdopen.html">fdopen</a></td>
<td>First calls <code>detach</code> (throwing on failure), then attempts to associate the given file descriptor with the <code>File</code> , and sets the file's name to <code>null</code> .</td>
</tr>
<tr>
<td><a href="../File/File/Functions/fileno.html">fileno</a></td>
<td>Returns the file number corresponding to this object.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/flush.html">flush</a></td>
<td>Flushes the C <code>FILE</code> buffers.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/getFP.html">getFP</a></td>
<td>Returns the <code>FILE*</code> corresponding to this object.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/initImpl.html">initImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Functions/isOpen.html">isOpen</a></td>
<td>Returns <code>true</code> if the file is opened.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/lock.html">lock</a></td>
<td>Locks the specified file segment. If the file segment is already locked by another process, waits until the existing lock is released. If both <code>start</code> and <code>length</code> are zero, the entire file is locked.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/lockImpl.html">lockImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Functions/lockingBinaryWriter.html">lockingBinaryWriter</a></td>
<td>Returns an output range that locks the file and allows fast writing to it.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/lockingTextWriter.html">lockingTextWriter</a></td>
<td>Output range which locks the file when created, and unlocks the file when it goes out of scope.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/name.html">name</a></td>
<td>Returns the name last used to initialize this <code>File</code> , if any.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/opAssign.html">opAssign</a></td>
<td>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/open.html">open</a></td>
<td>Detaches from the current file (throwing on failure), and then attempts to open file <code>name</code> with mode <code>stdioOpenmode</code>. The mode has the same semantics as in the C standard library $(CSTDIO fopen) function.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/popen.html">popen</a></td>
<td>Detaches from the current file (throwing on failure), and then runs a command by calling the C standard library function $(HTTP pubs.opengroup.org/onlinepubs/7908799/xsh/popen.html, popen).</td>
</tr>
<tr>
<td><a href="../File/File/Functions/rawRead.html">rawRead</a></td>
<td>Calls $(CSTDIO fread) for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/rawWrite.html">rawWrite</a></td>
<td>Calls $(CSTDIO fwrite) for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/readf.html">readf</a></td>
<td>Reads formatted <em>data from the file using $(REF formattedRead, std,</em> format). Params: format = The $(REF_ALTTEXT format string, formattedWrite, std, format). When passed as a compile-time argument, the string will be statically checked against the argument types passed. data = Items to be read. Returns: Same as <code>formattedRead</code> : The number of variables filled. If the input range <code>r</code> ends early, this number will be less than the number of variables provided. Example: ---- // test.d void main() { import std.stdio; auto f = File(&quot;input&quot;); foreach (_; 0 .. 3) { int a; f.readf!&quot; %d&quot;(a); writeln(++a); } } ---- $(CONSOLE % echo &quot;1 2 3&quot; &gt; input % rdmd test.d 2 3 4 )</td>
</tr>
<tr>
<td><a href="../File/File/Functions/readln.html">readln</a></td>
<td>Read line from the file handle and return it as a specified type.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/reopen.html">reopen</a></td>
<td>Reuses the <code>File</code> object to either open a different file, or change the file mode. If <code>name</code> is <code>null</code> , the mode of the currently open file is changed; otherwise, a new file is opened, reusing the C <code>FILE*</code> . The function has the same semantics as in the C standard library $(CSTDIO freopen) function.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/resetFile.html">resetFile</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Functions/rewind.html">rewind</a></td>
<td>Calls $(CSTDIO rewind) for the file handle.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/seek.html">seek</a></td>
<td>Calls $(CSTDIO fseek) for the file handle to move its position indicator.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/setAppendWin.html">setAppendWin</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Functions/setvbuf.html">setvbuf</a></td>
<td>Calls $(CSTDIO setvbuf) for the file handle.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/size.html">size</a></td>
<td>Returns the size of the file in bytes, ulong.max if file is not searchable or throws if the operation fails. Example: --- import std.stdio, std.file;</td>
</tr>
<tr>
<td><a href="../File/File/Functions/sync.html">sync</a></td>
<td>Forces any data buffered by the OS to be written to disk. Call $(LREF flush) before calling this function to flush the C <code>FILE</code> buffers first.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/tell.html">tell</a></td>
<td>Calls $(CSTDIO ftell) for the managed file handle, which returns the current value of the position indicator of the file handle.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/tmpfile.html">tmpfile</a></td>
<td>Returns a temporary file by calling $(CSTDIO tmpfile). Note that the created file has no $(LREF name).</td>
</tr>
<tr>
<td><a href="../File/File/Functions/tryLock.html">tryLock</a></td>
<td>Attempts to lock the specified file segment. If both <code>start</code> and <code>length</code> are zero, the entire file is locked. Returns: <code>true</code> if the lock was successful, and <code>false</code> if the specified file segment was already locked.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/unlock.html">unlock</a></td>
<td>Removes the lock over the specified file segment.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/windowsHandle.html">windowsHandle</a></td>
<td>Returns the underlying operating system <code>HANDLE</code> (Windows only).</td>
</tr>
<tr>
<td><a href="../File/File/Functions/windowsHandleOpen.html">windowsHandleOpen</a></td>
<td>First calls <code>detach</code> (throwing on failure), and then attempts to associate the given Windows <code>HANDLE</code> with the <code>File</code> . The mode must be compatible with the access attributes of the handle. Windows only.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/wrapFile.html">wrapFile</a></td>
<td>Unsafe function that wraps an existing <code>FILE*</code> . The resulting $(D File) never takes the initiative in closing the file. Note that the created file has no $(LREF name)</td>
</tr>
<tr>
<td><a href="../File/File/Functions/write.html">write</a></td>
<td>Writes its arguments in text format to the file.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/writef.html">writef</a></td>
<td>Writes its arguments in text format to the file, according to the format string fmt.</td>
</tr>
<tr>
<td><a href="../File/File/Functions/writefln.html">writefln</a></td>
<td>Equivalent to <code>file.writef(fmt, args, '\n')</code> .</td>
</tr>
<tr>
<td><a href="../File/File/Functions/writeln.html">writeln</a></td>
<td>Writes its arguments in text format to the file, followed by a newline.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../File/File/Structs/BinaryWriterImpl.html">BinaryWriterImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/ByChunkImpl.html">ByChunkImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/ByLineCopy.html">ByLineCopy</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/ByLineCopyImpl.html">ByLineCopyImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/ByLineImpl.html">ByLineImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/Impl.html">Impl</a></td>
<td></td>
</tr>
<tr>
<td><a href="../File/File/Structs/LockingTextWriter.html">LockingTextWriter</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
