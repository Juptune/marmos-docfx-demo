<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class - Socket | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class - Socket | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.socket.Classes.Socket">
<h1 class='section'>Class - Socket</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.socket</dd></dl>
</div><pre><code class='lang-d'>public class Socket
{
  // Accept an incoming connection. If the socket is blocking, `accept` waits for a connection request. Throws `SocketAcceptException` if unable to accept. See `accepting` for use with derived classes. 
  Socket accept() @trusted
  // Called by `accept` when a new `Socket` must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned `Socket` &#39;s handle must not be set; `Socket` has a protected constructor `this()` to use in this situation. 
  Socket accepting() nothrow pure
  // Get the socket&#39;s address family. 
  AddressFamily addressFamily() @property
  // Associate a local address with this socket. 
  void bind( Address addr ) @trusted
  // Get/set socket&#39;s blocking flag. 
  bool blocking() @nogc @property @trusted nothrow
  // ditto 
  void blocking( bool byes ) @property @trusted
  // 
  int capToInt( size_t size ) @nogc nothrow
  // Immediately drop any connections and release socket resources. The `Socket` object is no longer usable after `close` . Calling `shutdown` before `close` is recommended for connection-oriented sockets. 
  void close() @nogc @trusted nothrow scope
  // Establish a connection. If the socket is blocking, connect waits for the connection to be made. If the socket is nonblocking, connect returns immediately and the connection attempt is still in progress. 
  void connect( Address to ) @trusted
  // Can be overridden to support other addresses. Returns: A new `Address` object for the current address family. 
  Address createAddress() nothrow pure
  // Get a text description of this socket&#39;s error status, and clear the socket&#39;s error status. 
  string getErrorText() 
  // Get a socket option. Returns: The number of bytes written to `result` . The length, in bytes, of the actual result - very different from getsockopt() 
  int getOption(
    SocketOptionLevel level,
    SocketOption option,
    scope void[] result
  ) @trusted
  // Common case of getting integer and boolean options. 
  int getOption( SocketOptionLevel level, SocketOption option, out int32_t result ) @trusted
  // Get the linger option. 
  int getOption( SocketOptionLevel level, SocketOption option, out Linger result ) @trusted
  // Get a timeout (duration) option. 
  void getOption(
    SocketOptionLevel level,
    SocketOption option,
    out Duration result
  ) @trusted
  // Get underlying socket handle. 
  socket_t handle() @nogc @property nothrow pure
  // Returns: The local machine&#39;s host name 
  string hostName() @property @trusted
  // Property that indicates if this is a valid, alive socket. 
  bool isAlive() @property @trusted
  // Listen for an incoming connection. `bind` must be called before you can `listen` . The `backlog` is a request of how many pending incoming connections are queued until `accept` ed. 
  void listen( int backlog ) @trusted
  // Local endpoint `Address` . 
  Address localAddress() @property @trusted
  // Receive data on the connection. If the socket is blocking, `receive` waits until there is data to be received. Returns: The number of bytes actually received, `0` if the remote side has closed the connection, or `Socket.ERROR` on failure. 
  ptrdiff_t receive( scope void[] buf, SocketFlags flags ) @trusted
  // ditto 
  ptrdiff_t receive( scope void[] buf ) 
  // Receive data and get the remote endpoint `Address` . If the socket is blocking, `receiveFrom` waits until there is data to be received. Returns: The number of bytes actually received, `0` if the remote side has closed the connection, or `Socket.ERROR` on failure. 
  ptrdiff_t receiveFrom( scope void[] buf, SocketFlags flags, ref Address from ) @trusted
  // ditto 
  ptrdiff_t receiveFrom( scope void[] buf, ref Address from ) 
  // ditto 
  ptrdiff_t receiveFrom( scope void[] buf, SocketFlags flags ) @trusted
  // ditto 
  ptrdiff_t receiveFrom( scope void[] buf ) 
  // Releases the underlying socket handle from the Socket object. Once it is released, you cannot use the Socket object&#39;s methods anymore. This also means the Socket destructor will no longer close the socket - it becomes your responsibility. 
  socket_t release() @nogc @property nothrow pure
  // Remote endpoint `Address` . 
  Address remoteAddress() @property @trusted
  // Wait for a socket to change status. A wait timeout of $(REF Duration, core, time) or `TimeVal` , may be specified; if a timeout is not specified or the `TimeVal` is `null` , the maximum timeout is used. The `TimeVal` timeout has an unspecified value when `select` returns. Returns: The number of sockets with status changes, `0` on timeout, or `-1` on interruption. If the return value is greater than `0` , the `SocketSets` are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it&#39;s able to send. For a listening socket, a read status change means there is an incoming connection request and it&#39;s able to accept. 
  int select(
    SocketSet checkRead,
    SocketSet checkWrite,
    SocketSet checkError,
    Duration timeout
  ) @trusted
  // ditto 
  int select( SocketSet checkRead, SocketSet checkWrite, SocketSet checkError ) 
  // Ditto 
  int select(
    SocketSet checkRead,
    SocketSet checkWrite,
    SocketSet checkError,
    TimeVal* timeout
  ) @trusted
  // Send data on the connection. If the socket is blocking and there is no buffer space left, `send` waits. Returns: The number of bytes actually sent, or `Socket.ERROR` on failure. 
  ptrdiff_t send( scope void[] buf, SocketFlags flags ) @trusted
  // ditto 
  ptrdiff_t send( scope void[] buf ) 
  // Send data to a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, `sendTo` waits. Returns: The number of bytes actually sent, or `Socket.ERROR` on failure. 
  ptrdiff_t sendTo( scope void[] buf, SocketFlags flags, Address to ) @trusted
  // ditto 
  ptrdiff_t sendTo( scope void[] buf, Address to ) 
  // ditto 
  ptrdiff_t sendTo( scope void[] buf, SocketFlags flags ) @trusted
  // ditto 
  ptrdiff_t sendTo( scope void[] buf ) 
  // Enables TCP keep-alive with the specified parameters. 
  void setKeepAlive( int time, int interval ) @trusted
  // Set a socket option. 
  void setOption(
    SocketOptionLevel level,
    SocketOption option,
    scope void[] value
  ) @trusted
  // Common case for setting integer and boolean options. 
  void setOption( SocketOptionLevel level, SocketOption option, int32_t value ) @trusted
  // Set the linger option. 
  void setOption( SocketOptionLevel level, SocketOption option, Linger value ) @trusted
  // Sets a timeout (duration) option, i.e. `SocketOption.SNDTIMEO` or `RCVTIMEO` . Zero indicates no timeout. 
  void setOption( SocketOptionLevel level, SocketOption option, Duration value ) @trusted
  // 
  void setSock( socket_t handle ) 
  // Disables sends and/or receives. 
  void shutdown( SocketShutdown how ) @nogc @trusted nothrow

  // Send or receive error code. See `wouldHaveBlocked` , `lastSocketError` and `Socket.getErrorText` for obtaining more information about the error. 
  int ERROR = _SOCKET_ERROR
  // 
  socket_t sock
  // 
  &lt;enum or auto&gt; WINSOCK_TIMEOUT_SKEW = 500
}</code></pre><h2 class='section'>About</h2><p>Class that creates a network communication endpoint using the Berkeley sockets interface.</p>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../Socket/Socket/Functions/accept.html">accept</a></td>
<td>Accept an incoming connection. If the socket is blocking, <code>accept</code> waits for a connection request. Throws <code>SocketAcceptException</code> if unable to accept. See <code>accepting</code> for use with derived classes.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/accepting.html">accepting</a></td>
<td>Called by <code>accept</code> when a new <code>Socket</code> must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned <code>Socket</code> 's handle must not be set; <code>Socket</code> has a protected constructor <code>this()</code> to use in this situation.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/addressFamily.html">addressFamily</a></td>
<td>Get the socket's address family.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/bind.html">bind</a></td>
<td>Associate a local address with this socket.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/blocking.html">blocking</a></td>
<td>Get/set socket's blocking flag.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/capToInt.html">capToInt</a></td>
<td></td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/close.html">close</a></td>
<td>Immediately drop any connections and release socket resources. The <code>Socket</code> object is no longer usable after <code>close</code> . Calling <code>shutdown</code> before <code>close</code> is recommended for connection-oriented sockets.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/connect.html">connect</a></td>
<td>Establish a connection. If the socket is blocking, connect waits for the connection to be made. If the socket is nonblocking, connect returns immediately and the connection attempt is still in progress.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/createAddress.html">createAddress</a></td>
<td>Can be overridden to support other addresses. Returns: A new <code>Address</code> object for the current address family.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/getErrorText.html">getErrorText</a></td>
<td>Get a text description of this socket's error status, and clear the socket's error status.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/getOption.html">getOption</a></td>
<td>Get a socket option. Returns: The number of bytes written to <code>result</code> . The length, in bytes, of the actual result - very different from getsockopt()</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/handle.html">handle</a></td>
<td>Get underlying socket handle.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/hostName.html">hostName</a></td>
<td>Returns: The local machine's host name</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/isAlive.html">isAlive</a></td>
<td>Property that indicates if this is a valid, alive socket.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/listen.html">listen</a></td>
<td>Listen for an incoming connection. <code>bind</code> must be called before you can <code>listen</code> . The <code>backlog</code> is a request of how many pending incoming connections are queued until <code>accept</code> ed.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/localAddress.html">localAddress</a></td>
<td>Local endpoint <code>Address</code> .</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/receive.html">receive</a></td>
<td>Receive data on the connection. If the socket is blocking, <code>receive</code> waits until there is data to be received. Returns: The number of bytes actually received, <code>0</code> if the remote side has closed the connection, or <code>Socket.ERROR</code> on failure.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/receiveFrom.html">receiveFrom</a></td>
<td>Receive data and get the remote endpoint <code>Address</code> . If the socket is blocking, <code>receiveFrom</code> waits until there is data to be received. Returns: The number of bytes actually received, <code>0</code> if the remote side has closed the connection, or <code>Socket.ERROR</code> on failure.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/release.html">release</a></td>
<td>Releases the underlying socket handle from the Socket object. Once it is released, you cannot use the Socket object's methods anymore. This also means the Socket destructor will no longer close the socket - it becomes your responsibility.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/remoteAddress.html">remoteAddress</a></td>
<td>Remote endpoint <code>Address</code> .</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/select.html">select</a></td>
<td>Wait for a socket to change status. A wait timeout of $(REF Duration, core, time) or <code>TimeVal</code> , may be specified; if a timeout is not specified or the <code>TimeVal</code> is <code>null</code> , the maximum timeout is used. The <code>TimeVal</code> timeout has an unspecified value when <code>select</code> returns. Returns: The number of sockets with status changes, <code>0</code> on timeout, or <code>-1</code> on interruption. If the return value is greater than <code>0</code> , the <code>SocketSets</code> are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/send.html">send</a></td>
<td>Send data on the connection. If the socket is blocking and there is no buffer space left, <code>send</code> waits. Returns: The number of bytes actually sent, or <code>Socket.ERROR</code> on failure.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/sendTo.html">sendTo</a></td>
<td>Send data to a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, <code>sendTo</code> waits. Returns: The number of bytes actually sent, or <code>Socket.ERROR</code> on failure.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/setKeepAlive.html">setKeepAlive</a></td>
<td>Enables TCP keep-alive with the specified parameters.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/setOption.html">setOption</a></td>
<td>Set a socket option.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/setSock.html">setSock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../Socket/Socket/Functions/shutdown.html">shutdown</a></td>
<td>Disables sends and/or receives.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../Socket/Socket/Variables/ERROR.html">ERROR</a></td>
<td>Send or receive error code. See <code>wouldHaveBlocked</code> , <code>lastSocketError</code> and <code>Socket.getErrorText</code> for obtaining more information about the error.</td>
</tr>
<tr>
<td><a href="../Socket/Socket/Variables/sock.html">sock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../Socket/Socket/Variables/WINSOCK_TIMEOUT_SKEW.html">WINSOCK_TIMEOUT_SKEW</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
