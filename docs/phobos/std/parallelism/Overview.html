<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.parallelism | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.parallelism | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.parallelism.Overview">
<h1 class='section'>Module - std.parallelism</h1><h2 class='section'>About</h2><p><code>std.parallelism</code> implements high-level primitives for SMP parallelism. These include parallel foreach, parallel reduce, parallel eager map, pipelining and future/promise parallelism.  <code>std.parallelism</code> is recommended when the same operation is to be executed in parallel on different data, or when a function is to be executed in a background thread and its result returned to a well-defined main thread.  For communication between arbitrary threads, see <code>std.concurrency</code> .</p>
<p><code>std.parallelism</code> is based on the concept of a <code>Task</code> .  A <code>Task</code> is an object that represents the fundamental unit of work in this library and may be executed in parallel with any other <code>Task</code> .  Using <code>Task</code> directly allows programming with a future/promise paradigm.  All other supported parallelism paradigms (parallel foreach, map, reduce, pipelining) represent an additional level of abstraction over <code>Task</code> .  They automatically create one or more <code>Task</code> objects, or closely related types that are conceptually identical but not part of the public API.</p>
<p>After creation, a <code>Task</code> may be executed in a new thread, or submitted to a <code>TaskPool</code> for execution.  A <code>TaskPool</code> encapsulates a task queue and its worker threads.  Its purpose is to efficiently map a large number of <code>Task</code> s onto a smaller number of threads.  A task queue is a FIFO queue of <code>Task</code> objects that have been submitted to the <code>TaskPool</code> and are awaiting execution.  A worker thread is a thread that is associated with exactly one task queue.  It executes the <code>Task</code> at the front of its queue when the queue has work available, or sleeps when no work is available.  Each task queue is associated with zero or more worker threads.  If the result of a <code>Task</code> is needed before execution by a worker thread has begun, the <code>Task</code> can be removed from the task queue and executed immediately in the thread where the result is needed.</p>
<p>Warning:  Unless marked as <code>@trusted</code> or <code>@safe</code> , artifacts in this module allow implicit data sharing between threads and cannot guarantee that client code is free from low level data races.</p>
<p>Source:    $(PHOBOSSRC std/parallelism.d) Author:  David Simcha Copyright:  Copyright (c) 2009-2011, David Simcha. License:    $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0)</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/AliasReturn.html">AliasReturn</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/cacheLineSize.html">cacheLineSize</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/MapType.html">MapType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ReduceType.html">ReduceType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/totalCPUs.html">totalCPUs</a></td>
<td>The total number of CPU cores available on the current machine, as reported by the operating system.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Classes</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Classes/ParallelForeachError.html">ParallelForeachError</a></td>
<td></td>
</tr>
<tr>
<td><a href="Classes/ParallelismThread.html">ParallelismThread</a></td>
<td></td>
</tr>
<tr>
<td><a href="Classes/TaskPool.html">TaskPool</a></td>
<td>This class encapsulates a task queue and a set of worker threads.  Its purpose is to efficiently map a large number of <code>Task</code> s onto a smaller number of threads.  A task queue is a FIFO queue of <code>Task</code> objects that have been submitted to the <code>TaskPool</code> and are awaiting execution.  A worker thread is a thread that executes the <code>Task</code> at the front of the queue when one is available and sleeps when the queue is empty.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Enums/TaskStatus.html">TaskStatus</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/atomicCasUbyte.html">atomicCasUbyte</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/atomicReadUbyte.html">atomicReadUbyte</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/atomicSetUbyte.html">atomicSetUbyte</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/cacheLineSizeImpl.html">cacheLineSizeImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/defaultPoolThreads.html">defaultPoolThreads</a></td>
<td>These properties get and set the number of worker threads in the <code>TaskPool</code> instance returned by <code>taskPool</code> .  The default value is <code>totalCPUs</code> - 1. Calling the setter after the first call to <code>taskPool</code> does not changes number of worker threads in the instance returned by <code>taskPool</code> .</td>
</tr>
<tr>
<td><a href="Functions/doSizeZeroCase.html">doSizeZeroCase</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/foreachErr.html">foreachErr</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/parallel.html">parallel</a></td>
<td>Convenience functions that forwards to <code>taskPool.parallel</code> .  The purpose of these is to make parallel foreach less verbose and more readable.</td>
</tr>
<tr>
<td><a href="Functions/run.html">run</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/scopedTask.html">scopedTask</a></td>
<td>These functions allow the creation of <code>Task</code> objects on the stack rather than the GC heap.  The lifetime of a <code>Task</code> created by <code>scopedTask</code> cannot exceed the lifetime of the scope it was created in.</td>
</tr>
<tr>
<td><a href="Functions/submitAndExecute.html">submitAndExecute</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/task.html">task</a></td>
<td>Creates a <code>Task</code> on the GC heap that calls an alias.  This may be executed via <code>Task.executeInNewThread</code> or by submitting to a $(REF TaskPool, std,parallelism).  A globally accessible instance of <code>TaskPool</code> is provided by $(REF taskPool, std,parallelism).</td>
</tr>
<tr>
<td><a href="Functions/taskPool.html">taskPool</a></td>
<td>Returns a lazily initialized global instantiation of <code>TaskPool</code> . This function can safely be called concurrently from multiple non-worker threads.  The worker threads in this pool are daemon threads, meaning that it is not necessary to call <code>TaskPool.stop</code> or <code>TaskPool.finish</code> before terminating the main thread.</td>
</tr>
<tr>
<td><a href="Functions/totalCPUsImpl.html">totalCPUsImpl</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/AbstractTask.html">AbstractTask</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ParallelForeach.html">ParallelForeach</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/RoundRobinBuffer.html">RoundRobinBuffer</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Task.html">Task</a></td>
<td><code>Task</code> represents the fundamental unit of work.  A <code>Task</code> may be executed in parallel with any other <code>Task</code> .  Using this struct directly allows future/promise parallelism.  In this paradigm, a function (or delegate or other callable) is executed in a thread other than the one it was called from.  The calling thread does not block while the function is being executed. A call to <code>workForce</code> , <code>yieldForce</code> , or <code>spinForce</code> is used to ensure that the <code>Task</code> has finished executing and to obtain the return value, if any.  These functions and <code>done</code> also act as full memory barriers, meaning that any memory writes made in the thread that executed the <code>Task</code> are guaranteed to be visible in the calling thread after one of these functions returns.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Templates</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Templates/isSafeReturn.html">isSafeReturn</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/reduceAdjoin.html">reduceAdjoin</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/reduceFinish.html">reduceFinish</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/e.html">e</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isRoundRobin.html">isRoundRobin</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isRoundRobin.html">isRoundRobin</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isSafeTask.html">isSafeTask</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/noUnsharedAliasing.html">noUnsharedAliasing</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/parallelApplyMixinInputRange.html">parallelApplyMixinInputRange</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/parallelApplyMixinRandomAccess.html">parallelApplyMixinRandomAccess</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/poolInstance.html">poolInstance</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/randAssignable.html">randAssignable</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/randLen.html">randLen</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
