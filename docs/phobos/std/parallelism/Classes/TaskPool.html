<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class - TaskPool | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class - TaskPool | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.parallelism.Classes.TaskPool">
<h1 class='section'>Class - TaskPool</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.parallelism</dd></dl>
</div><pre><code class='lang-d'>public class TaskPool
{
  // 
  void abstractPut( AbstractTask* task ) 
  // 
  void abstractPutGroupNoSync( AbstractTask* h, AbstractTask* t ) 
  // 
  void abstractPutNoSync( AbstractTask* task ) 
  // 
  auto amap( Args... )( Args args ) 
  // Given a `source` range that is expensive to iterate over, returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) that asynchronously buffers the contents of `source` into a buffer of `bufSize` elements in a worker thread, while making previously buffered elements from a second buffer, also of size `bufSize` , available via the range interface of the returned object.  The returned range has a length iff `hasLength!S` . `asyncBuf` is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network. 
  auto asyncBuf( S )( S source, size_t bufSize ) 
  // Given a callable object `next` that writes to a user-provided buffer and a second callable object `empty` that determines whether more data is available to write via `next` , returns an input range that asynchronously calls `next` with a set of size `nBuffers` of buffers and makes the results available in the order they were obtained via the input range interface of the returned object.  Similarly to the input range overload of `asyncBuf` , the first half of the buffers are made available via the range interface while the second half are filled and vice-versa. 
  auto asyncBuf( C1, C2 )( C1 next, C2 empty, size_t initialBufSize, size_t nBuffers ) 
  // 
  size_t defaultWorkUnitSize( size_t rangeLen ) @safe nothrow pure
  // 
  bool deleteItem( AbstractTask* item ) 
  // 
  bool deleteItemNoSync( AbstractTask* item ) 
  // 
  void doJob( AbstractTask* job ) 
  // 
  void doSingleTask() 
  // 
  void executeWorkLoop() 
  // Signals worker threads to terminate when the queue becomes empty. 
  void finish( bool blocking ) @trusted
  // 
  auto fold( Args... )( Args args ) 
  // These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated.  A non-daemon thread will prevent a program from terminating as long as it has not terminated. 
  bool isDaemon() @property @trusted
  // Ditto 
  void isDaemon( bool newVal ) @property @trusted
  // 
  auto map( S )( S source, size_t bufSize, size_t workUnitSize ) 
  // 
  void notify() 
  // 
  void notifyAll() 
  // 
  void notifyWaiters() 
  // Implements a parallel foreach loop over a range.  This works by implicitly creating and submitting one `Task` to the `TaskPool` for each worker thread.  A work unit is a set of consecutive elements of `range` to be processed by a worker thread between communication with any other thread.  The number of elements processed per work unit is controlled by the `workUnitSize` parameter.  Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit.  Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger `workUnitSize` should be.  For very expensive loop bodies, `workUnitSize` should  be 1.  An overload that chooses a default work unit size is also available. 
  ParallelForeach!(R) parallel( R )( R range, size_t workUnitSize ) 
  // Ditto 
  ParallelForeach!(R) parallel( R )( R range ) 
  // 
  AbstractTask* pop() 
  // 
  AbstractTask* popNoSync() 
  // These functions allow getting and setting the OS scheduling priority of the worker threads in this `TaskPool` .  They forward to `core.thread.Thread.priority` , so a given priority value here means the same thing as an identical priority value in `core.thread` . 
  int priority() @property @trusted
  // Ditto 
  void priority( int newPriority ) @property @trusted
  // Put a `Task` object on the back of the task queue.  The `Task` object may be passed by pointer or reference. 
  void put( alias fun, Args... )( ref Task!(fun,Args) task ) 
  // Ditto 
  void put( alias fun, Args... )( Task!(fun,Args)* task ) 
  // 
  void put( alias fun, Args... )( ref Task!(fun,Args) task ) @trusted
  // 
  void put( alias fun, Args... )( Task!(fun,Args)* task ) @trusted
  // 
  void queueLock() 
  // 
  void queueUnlock() 
  // 
  auto reduce( Args... )( Args args ) 
  // Returns the number of worker threads in the pool. 
  size_t size() @property @safe nothrow pure
  // 
  void startWorkLoop() 
  // Signals to all worker threads to terminate as soon as they are finished with their current `Task` , or immediately if they are not executing a `Task` .  `Task` s that were in queue will not be executed unless a call to `Task.workForce` , `Task.yieldForce` or `Task.spinForce` causes them to be executed. 
  void stop() @trusted
  // 
  void tryDeleteExecute( AbstractTask* toExecute ) 
  // 
  void wait() 
  // 
  void waiterLock() 
  // 
  void waiterUnlock() 
  // 
  void waitUntilCompletion() 
  // Gets the index of the current thread relative to this `TaskPool` .  Any thread not in this pool will receive an index of 0.  The worker threads in this pool receive unique indices of 1 through `this.size` . 
  size_t workerIndex() @property @safe nothrow
  // Creates an instance of worker-local storage, initialized with a given value.  The value is `lazy` so that you can, for example, easily create one instance of a class for each worker.  For usage example, see the `WorkerLocalStorage` struct. 
  WorkerLocalStorage!(T) workerLocalStorage( T )( lazy T initialVal ) 

  // 
  AbstractTask* head
  // 
  immutable size_t instanceStartIndex
  // 
  bool isSingleTask
  // 
  __gshared size_t nextInstanceIndex = 1
  // 
  size_t nextThreadIndex
  // 
  ParallelismThread[] pool
  // 
  Mutex queueMutex
  // 
  Thread singleTaskThread
  // 
  PoolState status = PoolState.running
  // 
  AbstractTask* tail
  // 
  static size_t threadIndex
  // 
  Condition waiterCondition
  // 
  Mutex waiterMutex
  // 
  Condition workerCondition
}</code></pre><h2 class='section'>About</h2><p>This class encapsulates a task queue and a set of worker threads.  Its purpose is to efficiently map a large number of <code>Task</code> s onto a smaller number of threads.  A task queue is a FIFO queue of <code>Task</code> objects that have been submitted to the <code>TaskPool</code> and are awaiting execution.  A worker thread is a thread that executes the <code>Task</code> at the front of the queue when one is available and sleeps when the queue is empty.</p>
<p>This class should usually be used via the global instantiation available via the $(REF taskPool, std,parallelism) property. Occasionally it is useful to explicitly instantiate a <code>TaskPool</code> :</p>
<pre><code>1.1. When you want `TaskPool` instances with multiple priorities, for
</code></pre>
<p>example a low priority pool and a high priority pool.</p>
<pre><code>1.1. When the threads in the global task pool are waiting on a
</code></pre>
<p>synchronization primitive (for example a mutex), and you want to parallelize the code that needs to run before these threads can be resumed.</p>
<p>Note: The worker threads in this pool will not stop until <code>stop</code> or <code>finish</code> is called, even if the main thread has finished already. This may lead to programs that never end. If you do not want this behaviour, you can set <code>isDaemon</code> to true.</p>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../TaskPool/TaskPool/Enums/PoolState.html">PoolState</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/abstractPut.html">abstractPut</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/abstractPutGroupNoSync.html">abstractPutGroupNoSync</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/abstractPutNoSync.html">abstractPutNoSync</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/amap.html">amap</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/asyncBuf.html">asyncBuf</a></td>
<td>Given a <code>source</code> range that is expensive to iterate over, returns an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) that asynchronously buffers the contents of <code>source</code> into a buffer of <code>bufSize</code> elements in a worker thread, while making previously buffered elements from a second buffer, also of size <code>bufSize</code> , available via the range interface of the returned object.  The returned range has a length iff <code>hasLength!S</code> . <code>asyncBuf</code> is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/defaultWorkUnitSize.html">defaultWorkUnitSize</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/deleteItem.html">deleteItem</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/deleteItemNoSync.html">deleteItemNoSync</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/doJob.html">doJob</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/doSingleTask.html">doSingleTask</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/executeWorkLoop.html">executeWorkLoop</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/finish.html">finish</a></td>
<td>Signals worker threads to terminate when the queue becomes empty.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/fold.html">fold</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/isDaemon.html">isDaemon</a></td>
<td>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated.  A non-daemon thread will prevent a program from terminating as long as it has not terminated.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/map.html">map</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/notify.html">notify</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/notifyAll.html">notifyAll</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/notifyWaiters.html">notifyWaiters</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/parallel.html">parallel</a></td>
<td>Implements a parallel foreach loop over a range.  This works by implicitly creating and submitting one <code>Task</code> to the <code>TaskPool</code> for each worker thread.  A work unit is a set of consecutive elements of <code>range</code> to be processed by a worker thread between communication with any other thread.  The number of elements processed per work unit is controlled by the <code>workUnitSize</code> parameter.  Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit.  Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger <code>workUnitSize</code> should be.  For very expensive loop bodies, <code>workUnitSize</code> should  be 1.  An overload that chooses a default work unit size is also available.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/pop.html">pop</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/popNoSync.html">popNoSync</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/priority.html">priority</a></td>
<td>These functions allow getting and setting the OS scheduling priority of the worker threads in this <code>TaskPool</code> .  They forward to <code>core.thread.Thread.priority</code> , so a given priority value here means the same thing as an identical priority value in <code>core.thread</code> .</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/put.html">put</a></td>
<td>Put a <code>Task</code> object on the back of the task queue.  The <code>Task</code> object may be passed by pointer or reference.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/queueLock.html">queueLock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/queueUnlock.html">queueUnlock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/reduce.html">reduce</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/size.html">size</a></td>
<td>Returns the number of worker threads in the pool.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/startWorkLoop.html">startWorkLoop</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/stop.html">stop</a></td>
<td>Signals to all worker threads to terminate as soon as they are finished with their current <code>Task</code> , or immediately if they are not executing a <code>Task</code> .  <code>Task</code> s that were in queue will not be executed unless a call to <code>Task.workForce</code> , <code>Task.yieldForce</code> or <code>Task.spinForce</code> causes them to be executed.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/tryDeleteExecute.html">tryDeleteExecute</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/wait.html">wait</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/waiterLock.html">waiterLock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/waiterUnlock.html">waiterUnlock</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/waitUntilCompletion.html">waitUntilCompletion</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/workerIndex.html">workerIndex</a></td>
<td>Gets the index of the current thread relative to this <code>TaskPool</code> .  Any thread not in this pool will receive an index of 0.  The worker threads in this pool receive unique indices of 1 through <code>this.size</code> .</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Functions/workerLocalStorage.html">workerLocalStorage</a></td>
<td>Creates an instance of worker-local storage, initialized with a given value.  The value is <code>lazy</code> so that you can, for example, easily create one instance of a class for each worker.  For usage example, see the <code>WorkerLocalStorage</code> struct.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../TaskPool/TaskPool/Structs/WorkerLocalStorage.html">WorkerLocalStorage</a></td>
<td>Struct for creating worker-local storage.  Worker-local storage is thread-local storage that exists only for worker threads in a given <code>TaskPool</code> plus a single thread outside the pool.  It is allocated on the garbage collected heap in a way that avoids false sharing, and doesn't necessarily have global scope within any thread.  It can be accessed from any worker thread in the <code>TaskPool</code> that created it, and one thread outside this <code>TaskPool</code> .  All threads outside the pool that created a given instance of worker-local storage share a single slot.</td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Structs/WorkerLocalStorageRange.html">WorkerLocalStorageRange</a></td>
<td>Range primitives for worker-local storage.  The purpose of this is to access results produced by each worker thread from a single thread once you are no longer using the worker-local storage from multiple threads. Do not use this struct in the parallel portion of your algorithm.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/head.html">head</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/instanceStartIndex.html">instanceStartIndex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/isSingleTask.html">isSingleTask</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/nextInstanceIndex.html">nextInstanceIndex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/nextThreadIndex.html">nextThreadIndex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/pool.html">pool</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/queueMutex.html">queueMutex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/singleTaskThread.html">singleTaskThread</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/status.html">status</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/tail.html">tail</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/threadIndex.html">threadIndex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/waiterCondition.html">waiterCondition</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/waiterMutex.html">waiterMutex</a></td>
<td></td>
</tr>
<tr>
<td><a href="../TaskPool/TaskPool/Variables/workerCondition.html">workerCondition</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
