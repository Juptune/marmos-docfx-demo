<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.traits | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.traits | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.traits.Overview">
<h1 class='section'>Module - std.traits</h1><h2 class='section'>About</h2><p>Templates which extract information about types and symbols at compile time.</p>
<p>$(SCRIPT inhibitQuickIndex = 1;)</p>
<p>$(DIVC quickindex, $(BOOKTABLE , $(TR $(TH Category) $(TH Templates)) $(TR $(TD Symbol Name traits) $(TD $(LREF fullyQualifiedName) $(LREF mangledName) $(LREF moduleName) $(LREF packageName) )) $(TR $(TD Function traits) $(TD $(LREF isFunction) $(LREF arity) $(LREF functionAttributes) $(LREF hasFunctionAttributes) $(LREF functionLinkage) $(LREF FunctionTypeOf) $(LREF isSafe) $(LREF isUnsafe) $(LREF isFinal) $(LREF ParameterDefaults) $(LREF ParameterIdentifierTuple) $(LREF ParameterStorageClassTuple) $(LREF Parameters) $(LREF ReturnType) $(LREF SetFunctionAttributes) $(LREF variadicFunctionStyle) )) $(TR $(TD Aggregate Type traits) $(TD $(LREF BaseClassesTuple) $(LREF BaseTypeTuple) $(LREF classInstanceAlignment) $(LREF EnumMembers) $(LREF FieldNameTuple) $(LREF Fields) $(LREF hasAliasing) $(LREF hasElaborateAssign) $(LREF hasElaborateCopyConstructor) $(LREF hasElaborateDestructor) $(LREF hasElaborateMove) $(LREF hasIndirections) $(LREF hasMember) $(LREF hasStaticMember) $(LREF hasNested) $(LREF hasUnsharedAliasing) $(LREF InterfacesTuple) $(LREF isInnerClass) $(LREF isNested) $(LREF MemberFunctionsTuple) $(LREF RepresentationTypeTuple) $(LREF TemplateArgsOf) $(LREF TemplateOf) $(LREF TransitiveBaseTypeTuple) )) $(TR $(TD Type Conversion) $(TD $(LREF CommonType) $(LREF AllImplicitConversionTargets) $(LREF ImplicitConversionTargets) $(LREF CopyTypeQualifiers) $(LREF CopyConstness) $(LREF isAssignable) $(LREF isCovariantWith) $(LREF isImplicitlyConvertible) $(LREF isQualifierConvertible) )) $(TR $(TD Type Constructors) $(TD $(LREF InoutOf) $(LREF ConstOf) $(LREF SharedOf) $(LREF SharedInoutOf) $(LREF SharedConstOf) $(LREF SharedConstInoutOf) $(LREF ImmutableOf) $(LREF QualifierOf) )) $(TR $(TD Categories of types) $(TD $(LREF allSameType) $(LREF ifTestable) $(LREF isType) $(LREF isAggregateType) $(LREF isArray) $(LREF isAssociativeArray) $(LREF isAutodecodableString) $(LREF isBasicType) $(LREF isBoolean) $(LREF isBuiltinType) $(LREF isCopyable) $(LREF isDynamicArray) $(LREF isEqualityComparable) $(LREF isFloatingPoint) $(LREF isIntegral) $(LREF isNarrowString) $(LREF isConvertibleToString) $(LREF isNumeric) $(LREF isOrderingComparable) $(LREF isPointer) $(LREF isScalarType) $(LREF isSigned) $(LREF isSIMDVector) $(LREF isSomeChar) $(LREF isSomeString) $(LREF isStaticArray) $(LREF isUnsigned) )) $(TR $(TD Type behaviours) $(TD $(LREF isAbstractClass) $(LREF isAbstractFunction) $(LREF isCallable) $(LREF isDelegate) $(LREF isExpressions) $(LREF isFinalClass) $(LREF isFinalFunction) $(LREF isFunctionPointer) $(LREF isInstanceOf) $(LREF isIterable) $(LREF isMutable) $(LREF isSomeFunction) $(LREF isTypeTuple) )) $(TR $(TD General Types) $(TD $(LREF ForeachType) $(LREF KeyType) $(LREF Largest) $(LREF mostNegative) $(LREF OriginalType) $(LREF PointerTarget) $(LREF Signed) $(LREF Unconst) $(LREF Unshared) $(LREF Unqual) $(LREF Unsigned) $(LREF ValueType) $(LREF Promoted) )) $(TR $(TD Misc) $(TD $(LREF lvalueOf) $(LREF rvalueOf) $(LREF Select) $(LREF select) )) $(TR $(TD User-Defined Attributes) $(TD $(LREF hasUDA) $(LREF getUDAs) $(LREF getSymbolsByUDA) )) ) )</p>
<p>Copyright: Copyright The D Language Foundation 2005 - 2009. License:   $(HTTP <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>, Boost License 1.0). Authors:   $(HTTP digitalmars.com, Walter Bright), Tomasz Stachowiak (<code>isExpressions</code>), $(HTTP erdani.org, Andrei Alexandrescu), Shin Fujishiro, $(HTTP octarineparrot.com, Robert Clipsham), $(HTTP klickverbot.at, David Nadlinger), Kenji Hara, Shoichi Kato Source:    $(PHOBOSSRC std/traits.d)</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/CentTypeList.html">CentTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/CharTypeList.html">CharTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ComplexTypeList.html">ComplexTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ConstOf.html">ConstOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/CopyConstness.html">CopyConstness</a></td>
<td>Returns the type of <code>ToType</code> with the &quot;constness&quot; of <code>FromType</code> . A type's $(B constness) refers to whether it is <code>const</code> , <code>immutable</code> , or <code>inout</code> . If <code>FromType</code> has no constness, the returned type will be the same as <code>ToType</code> .</td>
</tr>
<tr>
<td><a href="Aliases/CopyTypeQualifiers.html">CopyTypeQualifiers</a></td>
<td>Copies type qualifiers from <code>FromType</code> to <code>ToType</code> .</td>
</tr>
<tr>
<td><a href="Aliases/DynamicArrayTypeOf.html">DynamicArrayTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Fields.html">Fields</a></td>
<td>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If <code>T</code> isn't a struct, class, interface or union returns a tuple with one element <code>T</code> .</td>
</tr>
<tr>
<td><a href="Aliases/FieldTypeTuple.html">FieldTypeTuple</a></td>
<td>Alternate name for $(LREF Fields), kept for legacy compatibility.</td>
</tr>
<tr>
<td><a href="Aliases/FloatingPointTypeList.html">FloatingPointTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ForeachType.html">ForeachType</a></td>
<td>Returns the inferred type of the loop variable when a variable of type T is iterated over using a <code>foreach</code> loop with a single loop variable and automatically inferred return type.  Note that this may not be the same as <code>std.range.ElementType!Range</code> in the case of narrow strings, or if T has both opApply and a range interface.</td>
</tr>
<tr>
<td><a href="Aliases/FuncSym.html">FuncSym</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/getUDAs.html">getUDAs</a></td>
<td>Gets the matching $(DDSUBLINK spec/attribute, uda, user-defined attributes) from the given symbol.</td>
</tr>
<tr>
<td><a href="Aliases/hasElaborateCopyConstructor.html">hasElaborateCopyConstructor</a></td>
<td>True if <code>S</code> or any type embedded directly in the representation of <code>S</code> defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining <code>this(this)</code> for a <code>struct</code> .</td>
</tr>
<tr>
<td><a href="Aliases/hasElaborateDestructor.html">hasElaborateDestructor</a></td>
<td>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate destructor. Elaborate destructors are introduced by defining <code>~this()</code> for a $(D struct).</td>
</tr>
<tr>
<td><a href="Aliases/hasElaborateMove.html">hasElaborateMove</a></td>
<td>True if <code>S</code> or any type embedded directly in the representation of <code>S</code> defines elaborate move semantics. Elaborate move semantics are introduced by defining <code>opPostMove(ref typeof(this))</code> for a <code>struct</code> .</td>
</tr>
<tr>
<td><a href="Aliases/hasIndirections.html">hasIndirections</a></td>
<td>Returns <code>true</code> if and only if <code>T</code> 's representation includes at least one of the following: $(OL $(LI a raw pointer <code>U*</code> ;) $(LI an array <code>U[]</code> ;) $(LI a reference to a class type <code>C</code> ;) $(LI an associative array;) $(LI a delegate;) $(LI a [context pointer][isNested].))</td>
</tr>
<tr>
<td><a href="Aliases/Identity.html">Identity</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ImaginaryTypeList.html">ImaginaryTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ImmutableOf.html">ImmutableOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/InoutOf.html">InoutOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/IntegralTypeList.html">IntegralTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/isExpressionTuple.html">isExpressionTuple</a></td>
<td>Alternate name for $(LREF isExpressions), kept for legacy compatibility.</td>
</tr>
<tr>
<td><a href="Aliases/KeyType.html">KeyType</a></td>
<td>Get the Key type of an Associative Array.</td>
</tr>
<tr>
<td><a href="Aliases/ModifyTypePreservingTQ.html">ModifyTypePreservingTQ</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/NumericTypeList.html">NumericTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/OriginalType.html">OriginalType</a></td>
<td>Strips off all <code>enum</code> s from type <code>T</code> .</td>
</tr>
<tr>
<td><a href="Aliases/ParameterDefaultValueTuple.html">ParameterDefaultValueTuple</a></td>
<td>Alternate name for $(LREF ParameterDefaults), kept for legacy compatibility.</td>
</tr>
<tr>
<td><a href="Aliases/ParameterTypeTuple.html">ParameterTypeTuple</a></td>
<td>Alternate name for $(LREF Parameters), kept for legacy compatibility.</td>
</tr>
<tr>
<td><a href="Aliases/parentOf.html">parentOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/parentOf.html">parentOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/PointerTarget.html">PointerTarget</a></td>
<td>Returns the target type of a pointer.</td>
</tr>
<tr>
<td><a href="Aliases/Pointify.html">Pointify</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Promoted.html">Promoted</a></td>
<td>Get the type that a scalar type <code>T</code> will $(LINK2 $(ROOT_DIR)spec/type.html#integer-promotions, promote) to in multi-term arithmetic expressions.</td>
</tr>
<tr>
<td><a href="Aliases/Select.html">Select</a></td>
<td>Aliases itself to <code>T[0]</code> if the boolean <code>condition</code> is <code>true</code> and to <code>T[1]</code> otherwise.</td>
</tr>
<tr>
<td><a href="Aliases/SetFunctionAttributes.html">SetFunctionAttributes</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Aliases/SharedConstInoutOf.html">SharedConstInoutOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/SharedConstOf.html">SharedConstOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/SharedInoutOf.html">SharedInoutOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/SharedOf.html">SharedOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Signed.html">Signed</a></td>
<td>Returns the corresponding signed type for T. T must be a numeric integral type, otherwise a compile-time error occurs.</td>
</tr>
<tr>
<td><a href="Aliases/SignedCentTypeList.html">SignedCentTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/SignedIntTypeList.html">SignedIntTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/staticMap.html">staticMap</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/T.html">T</a></td>
<td>Copies type qualifiers from <code>FromType</code> to <code>ToType</code> .</td>
</tr>
<tr>
<td><a href="Aliases/TemplateArgsOf.html">TemplateArgsOf</a></td>
<td>Returns a <code>AliasSeq</code> of the template arguments used to instantiate <code>T</code> .</td>
</tr>
<tr>
<td><a href="Aliases/TemplateArgsOf.html">TemplateArgsOf</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/TemplateOf.html">TemplateOf</a></td>
<td>Returns an alias to the template that <code>T</code> is an instance of. It will return <code>void</code> if a symbol without a template is given.</td>
</tr>
<tr>
<td><a href="Aliases/TemplateOf.html">TemplateOf</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/TemplateOf.html">TemplateOf</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/TransitiveBaseTypeTuple.html">TransitiveBaseTypeTuple</a></td>
<td>Get a $(D_PARAM AliasSeq) of $(I all) base classes of $(D_PARAM T), in decreasing order, followed by $(D_PARAM T)'s interfaces. $(D_PARAM TransitiveBaseTypeTuple!Object) yields the empty type tuple.</td>
</tr>
<tr>
<td><a href="Aliases/TypeQualifierList.html">TypeQualifierList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Unconst.html">Unconst</a></td>
<td>Removes <code>const</code> , <code>inout</code> and <code>immutable</code> qualifiers, if any, from type <code>T</code> .</td>
</tr>
<tr>
<td><a href="Aliases/Unqual.html">Unqual</a></td>
<td>Removes all qualifiers, if any, from type <code>T</code> .</td>
</tr>
<tr>
<td><a href="Aliases/Unshared.html">Unshared</a></td>
<td>Returns the type of <code>ToType</code> with the &quot;constness&quot; of <code>FromType</code> . A type's $(B constness) refers to whether it is <code>const</code> , <code>immutable</code> , or <code>inout</code> . If <code>FromType</code> has no constness, the returned type will be the same as <code>ToType</code> .</td>
</tr>
<tr>
<td><a href="Aliases/Unshared.html">Unshared</a></td>
<td>Returns the type of <code>ToType</code> with the &quot;constness&quot; of <code>FromType</code> . A type's $(B constness) refers to whether it is <code>const</code> , <code>immutable</code> , or <code>inout</code> . If <code>FromType</code> has no constness, the returned type will be the same as <code>ToType</code> .</td>
</tr>
<tr>
<td><a href="Aliases/Unsigned.html">Unsigned</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/UnsignedCentTypeList.html">UnsignedCentTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/UnsignedIntTypeList.html">UnsignedIntTypeList</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/ValueType.html">ValueType</a></td>
<td>Get the Value type of an Associative Array.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Enums/FunctionAttribute.html">FunctionAttribute</a></td>
<td>Returns the FunctionAttribute mask for function <code>func</code> .</td>
</tr>
<tr>
<td><a href="Enums/ParameterStorageClass.html">ParameterStorageClass</a></td>
<td>Get a tuple of the storage classes of a function's parameters. Params: func = function symbol or type of function, delegate, or pointer to function Returns: A tuple of ParameterStorageClass bits</td>
</tr>
<tr>
<td><a href="Enums/QualifiedEnum.html">QualifiedEnum</a></td>
<td></td>
</tr>
<tr>
<td><a href="Enums/Variadic.html">Variadic</a></td>
<td>Determines what kind of variadic parameters function has. Params: func = function symbol or type of function, delegate, or pointer to function Returns: enum Variadic</td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/adjustIdent.html">adjustIdent</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/cstyle.html">cstyle</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/dip1000Test.html">dip1000Test</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/dstyle.html">dstyle</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/extractAttribFlags.html">extractAttribFlags</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/freeFunc.html">freeFunc</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/issue20054.html">issue20054</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/lvalueOf.html">lvalueOf</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/novar.html">novar</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/rvalueOf.html">rvalueOf</a></td>
<td>Creates an lvalue or rvalue of type <code>T</code> for <code>typeof(...)</code> and $(DDSUBLINK spec/traits, compiles, <code>__traits(compiles, ...)</code> ) purposes. No actual value is returned.</td>
</tr>
<tr>
<td><a href="Functions/sc.html">sc</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/select.html">select</a></td>
<td>Select one of two functions to run via template parameter.</td>
</tr>
<tr>
<td><a href="Functions/typesafe.html">typesafe</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/QualifiedNameTests.html">QualifiedNameTests</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/SubTypeOf.html">SubTypeOf</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Templates</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Templates/AllImplicitConversionTargets.html">AllImplicitConversionTargets</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/ArrayTypeOf.html">ArrayTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/AssocArrayTypeOf.html">AssocArrayTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/BaseClassesTuple.html">BaseClassesTuple</a></td>
<td>Get a $(D_PARAM AliasSeq) of $(I all) base classes of this class, in decreasing order. Interfaces are not included. $(D_PARAM BaseClassesTuple!Object) yields the empty type tuple.</td>
</tr>
<tr>
<td><a href="Templates/BaseTypeTuple.html">BaseTypeTuple</a></td>
<td>Get a $(D_PARAM AliasSeq) of the base class and base interfaces of this class or interface. $(D_PARAM BaseTypeTuple!Object) returns the empty type tuple.</td>
</tr>
<tr>
<td><a href="Templates/BooleanTypeOf.html">BooleanTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/BuiltinTypeOf.html">BuiltinTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/CharTypeOf.html">CharTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/CommonType.html">CommonType</a></td>
<td>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns $(D_PARAM void) if passed an empty list, or if the types have no common type.</td>
</tr>
<tr>
<td><a href="Templates/convertToString.html">convertToString</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/DeducedParameterType.html">DeducedParameterType</a></td>
<td>The parameter type deduced by IFTI when an expression of type T is passed as an argument to a template function.</td>
</tr>
<tr>
<td><a href="Templates/EnumMembers.html">EnumMembers</a></td>
<td>Retrieves the members of an enumerated type <code>enum E</code> .</td>
</tr>
<tr>
<td><a href="Templates/FieldNameTuple.html">FieldNameTuple</a></td>
<td>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If <code>T</code> isn't a struct, class, interface or union, an expression tuple with an empty string is returned.</td>
</tr>
<tr>
<td><a href="Templates/FloatingPointTypeOf.html">FloatingPointTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/fqnTuple.html">fqnTuple</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/fqnType.html">fqnType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/FunctionTypeOf.html">FunctionTypeOf</a></td>
<td>Get the function type from a callable object <code>func</code> , or from a function pointer/delegate type.</td>
</tr>
<tr>
<td><a href="Templates/getSymbolsByUDA.html">getSymbolsByUDA</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/getSymbolsByUDAImpl.html">getSymbolsByUDAImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasAliasingImpl.html">hasAliasingImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasElaborateAssign.html">hasElaborateAssign</a></td>
<td>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate assignment. Elaborate assignments are introduced by defining <code>opAssign(typeof(this))</code> or $(D opAssign(ref typeof(this))) for a <code>struct</code> or when there is a compiler-generated <code>opAssign</code> .</td>
</tr>
<tr>
<td><a href="Templates/hasNested.html">hasNested</a></td>
<td>Determines whether <code>T</code> or any of its representation types have a context pointer.</td>
</tr>
<tr>
<td><a href="Templates/hasObjects.html">hasObjects</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasRawAliasingImpl.html">hasRawAliasingImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasRawUnsharedAliasingImpl.html">hasRawUnsharedAliasingImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasStaticMember.html">hasStaticMember</a></td>
<td>Whether the symbol represented by the string, member, exists and is a static member of T.</td>
</tr>
<tr>
<td><a href="Templates/hasUnsharedAliasingImpl.html">hasUnsharedAliasingImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/hasUnsharedObjects.html">hasUnsharedObjects</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/Impl.html">Impl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/Impl.html">Impl</a></td>
<td>Returns the corresponding signed type for T. T must be a numeric integral type, otherwise a compile-time error occurs.</td>
</tr>
<tr>
<td><a href="Templates/ImplicitConversionTargets.html">ImplicitConversionTargets</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/IntegralTypeOf.html">IntegralTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/InterfacesTuple.html">InterfacesTuple</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/isAliasSeq.html">isAliasSeq</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/isBlitAssignable.html">isBlitAssignable</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/isCallable.html">isCallable</a></td>
<td>Detect whether <code>T</code> is a callable object, which can be called with the function call operator <code>$(LPAREN)...$(RPAREN)</code> .</td>
</tr>
<tr>
<td><a href="Templates/isCovariantWith.html">isCovariantWith</a></td>
<td>Determines whether the function type <code>F</code> is covariant with <code>G</code> , i.e., functions of the type <code>F</code> can override ones of the type <code>G</code> .</td>
</tr>
<tr>
<td><a href="Templates/isDesiredUDA.html">isDesiredUDA</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/isDynamicArray.html">isDynamicArray</a></td>
<td>Detect whether type <code>T</code> is a dynamic array.</td>
</tr>
<tr>
<td><a href="Templates/isExpressions.html">isExpressions</a></td>
<td>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions.</td>
</tr>
<tr>
<td><a href="Templates/isFinal.html">isFinal</a></td>
<td>Detect whether <code>X</code> is a final method or class.</td>
</tr>
<tr>
<td><a href="Templates/isFunction.html">isFunction</a></td>
<td>Detect whether symbol or type <code>X</code> is a function. This is different that finding if a symbol is callable or satisfying <code>is(X == function)</code> , it finds specifically if the symbol represents a normal function declaration, i.e. not a delegate or a function pointer.</td>
</tr>
<tr>
<td><a href="Templates/isInnerClass.html">isInnerClass</a></td>
<td>Determines whether <code>T</code> is a class nested inside another class and that <code>T.outer</code> is the implicit reference to the outer class (i.e. <code>outer</code> has not been used as a field or method name)</td>
</tr>
<tr>
<td><a href="Templates/isIntegral.html">isIntegral</a></td>
<td>Detect whether <code>T</code> is a built-in integral type. Integral types are <code>byte</code> , <code>ubyte</code> , <code>short</code> , <code>ushort</code> , <code>int</code> , <code>uint</code> , <code>long</code> , <code>ulong</code> , <code>cent</code> , <code>ucent</code> , and enums with an integral type as its base type. Params: T = type to test Returns: <code>true</code> if <code>T</code> is an integral type Note: this is not the same as $(LINK2 <a href="https://dlang.org/spec/traits.html#isIntegral">https://dlang.org/spec/traits.html#isIntegral</a>, <code>__traits(isIntegral)</code> )</td>
</tr>
<tr>
<td><a href="Templates/isNumeric.html">isNumeric</a></td>
<td>Detect whether <code>T</code> is a built-in numeric type (integral or floating point).</td>
</tr>
<tr>
<td><a href="Templates/isSomeChar.html">isSomeChar</a></td>
<td>Detect whether <code>T</code> is one of the built-in character types.</td>
</tr>
<tr>
<td><a href="Templates/isUnsigned.html">isUnsigned</a></td>
<td>Detect whether <code>T</code> is a built-in unsigned numeric type.</td>
</tr>
<tr>
<td><a href="Templates/Largest.html">Largest</a></td>
<td>Returns the largest type, i.e. T such that T.sizeof is the largest.  If more than one type is of the same size, the leftmost argument of these in will be returned.</td>
</tr>
<tr>
<td><a href="Templates/MemberFunctionsTuple.html">MemberFunctionsTuple</a></td>
<td>Returns a tuple of non-static functions with the name <code>name</code> declared in the class or interface <code>C</code> .  Covariant duplicates are shrunk into the most derived one.</td>
</tr>
<tr>
<td><a href="Templates/moduleName.html">moduleName</a></td>
<td>Get the module name (including package) for the given symbol.</td>
</tr>
<tr>
<td><a href="Templates/mostNegative.html">mostNegative</a></td>
<td>Returns the most negative value of the numeric type T.</td>
</tr>
<tr>
<td><a href="Templates/NumericTypeOf.html">NumericTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/packageName.html">packageName</a></td>
<td>Get the full package name for the given symbol.</td>
</tr>
<tr>
<td><a href="Templates/ParameterDefaults.html">ParameterDefaults</a></td>
<td>Get, as a tuple, the default values of the parameters to a function symbol. If a parameter doesn't have the default value, <code>void</code> is returned instead.</td>
</tr>
<tr>
<td><a href="Templates/ParameterIdentifierTuple.html">ParameterIdentifierTuple</a></td>
<td>Get, as a tuple, the identifiers of the parameters to a function symbol.</td>
</tr>
<tr>
<td><a href="Templates/Parameters.html">Parameters</a></td>
<td>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an <code>opCall</code> , a pointer to a struct with an <code>opCall</code> , or a class with an <code>opCall</code> .</td>
</tr>
<tr>
<td><a href="Templates/ParameterStorageClassTuple.html">ParameterStorageClassTuple</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Templates/QualifierOf.html">QualifierOf</a></td>
<td>Gives a template that can be used to apply the same attributes that are on the given type <code>T</code> . E.g. passing <code>inout shared int</code> will return <code>SharedInoutOf</code> .</td>
</tr>
<tr>
<td><a href="Templates/RepresentationTypeTuple.html">RepresentationTypeTuple</a></td>
<td>Get the primitive types of the fields of a struct or class, in topological order.</td>
</tr>
<tr>
<td><a href="Templates/RepresentationTypeTupleImpl.html">RepresentationTypeTupleImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/ReturnType.html">ReturnType</a></td>
<td>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an <code>opCall</code> . Please note that $(D_KEYWORD ref) is not part of a type, but the attribute of the function (see template $(LREF functionAttributes)).</td>
</tr>
<tr>
<td><a href="Templates/SetFunctionAttributes.html">SetFunctionAttributes</a></td>
<td>Constructs a new function or delegate type with the same basic signature as the given one, but different attributes (including linkage).</td>
</tr>
<tr>
<td><a href="Templates/SignedTypeOf.html">SignedTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/StaticArrayTypeOf.html">StaticArrayTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/StringTypeOf.html">StringTypeOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/Unshared.html">Unshared</a></td>
<td>Removes <code>shared</code> qualifier, if any, from type <code>T</code> .</td>
</tr>
<tr>
<td><a href="Templates/UnsignedTypeOf.html">UnsignedTypeOf</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/allSameType.html">allSameType</a></td>
<td>Returns: <code>true</code> iff all types <code>Ts</code> are the same.</td>
</tr>
<tr>
<td><a href="Variables/arity.html">arity</a></td>
<td>Returns the number of arguments of function <code>func</code> . arity is undefined for variadic functions.</td>
</tr>
<tr>
<td><a href="Variables/classInstanceAlignment.html">classInstanceAlignment</a></td>
<td>Returns class instance alignment.</td>
</tr>
<tr>
<td><a href="Variables/dip1000Enabled.html">dip1000Enabled</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/extractParameterStorageClassFlags.html">extractParameterStorageClassFlags</a></td>
<td>Convert the result of $(DDSUBLINK spec/traits, getParameterStorageClasses, <code>__traits(getParameterStorageClasses)</code> ) to $(LREF ParameterStorageClass) <code>enum</code> s.</td>
</tr>
<tr>
<td><a href="Variables/fqnSym.html">fqnSym</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/fqnSym.html">fqnSym</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/fullyQualifiedName.html">fullyQualifiedName</a></td>
<td>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.</td>
</tr>
<tr>
<td><a href="Variables/fullyQualifiedName.html">fullyQualifiedName</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/functionAttributes.html">functionAttributes</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/functionLinkage.html">functionLinkage</a></td>
<td>Determine the linkage attribute of the function. Params: func = the function symbol, or the type of a function, delegate, or pointer to function Returns: one of the strings &quot;D&quot;, &quot;C&quot;, &quot;C++&quot;, &quot;Windows&quot;, &quot;Objective-C&quot;, or &quot;System&quot;.</td>
</tr>
<tr>
<td><a href="Variables/hasAliasing.html">hasAliasing</a></td>
<td>Returns <code>true</code> if and only if <code>T</code> 's representation includes at least one of the following: $(OL $(LI a raw pointer <code>U*</code> and <code>U</code> is not immutable;) $(LI an array <code>U[]</code> and <code>U</code> is not immutable;) $(LI a reference to a class or interface type <code>C</code> and <code>C</code> is not immutable.) $(LI an associative array that is not immutable.) $(LI a delegate.))</td>
</tr>
<tr>
<td><a href="Variables/hasFunctionAttributes.html">hasFunctionAttributes</a></td>
<td>Checks whether a function has the given attributes attached.</td>
</tr>
<tr>
<td><a href="Variables/hasMember.html">hasMember</a></td>
<td>Yields <code>true</code> if and only if <code>T</code> is an aggregate that defines a symbol called <code>name</code> .</td>
</tr>
<tr>
<td><a href="Variables/hasRawAliasing.html">hasRawAliasing</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/hasRawUnsharedAliasing.html">hasRawUnsharedAliasing</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/hasUDA.html">hasUDA</a></td>
<td>Determine if a symbol has a given $(DDSUBLINK spec/attribute, uda, user-defined attribute).</td>
</tr>
<tr>
<td><a href="Variables/hasUnsharedAliasing.html">hasUnsharedAliasing</a></td>
<td>Returns <code>true</code> if and only if <code>T</code> 's representation includes at least one of the following: $(OL $(LI a raw pointer <code>U*</code> and <code>U</code> is not immutable or shared;) $(LI an array <code>U[]</code> and <code>U</code> is not immutable or shared;) $(LI a reference to a class type <code>C</code> and <code>C</code> is not immutable or shared.) $(LI an associative array that is not immutable or shared.) $(LI a delegate that is not shared.))</td>
</tr>
<tr>
<td><a href="Variables/ifTestable.html">ifTestable</a></td>
<td>Returns: <code>true</code> iff the type <code>T</code> can be tested in an $(D if)-expression, that is if $(D if (pred(T.init)) {}) is compilable.</td>
</tr>
<tr>
<td><a href="Variables/impl.html">impl</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/impl.html">impl</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/isAbstractClass.html">isAbstractClass</a></td>
<td>Detect whether <code>S</code> is an abstract class.</td>
</tr>
<tr>
<td><a href="Variables/isAbstractFunction.html">isAbstractFunction</a></td>
<td>Detect whether <code>S</code> is an abstract function.</td>
</tr>
<tr>
<td><a href="Variables/isAggregateType.html">isAggregateType</a></td>
<td>Detect whether type <code>T</code> is an aggregate type.</td>
</tr>
<tr>
<td><a href="Variables/isArray.html">isArray</a></td>
<td>Detect whether type <code>T</code> is an array (static or dynamic; for associative arrays see $(LREF isAssociativeArray)).</td>
</tr>
<tr>
<td><a href="Variables/isAssignable.html">isAssignable</a></td>
<td>Returns <code>true</code> iff a value of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code> .</td>
</tr>
<tr>
<td><a href="Variables/isAssociativeArray.html">isAssociativeArray</a></td>
<td>Detect whether <code>T</code> is an associative array type</td>
</tr>
<tr>
<td><a href="Variables/isAutodecodableString.html">isAutodecodableString</a></td>
<td>Detect whether type <code>T</code> is a string that will be autodecoded.</td>
</tr>
<tr>
<td><a href="Variables/isBasicType.html">isBasicType</a></td>
<td>Detect whether <code>T</code> is a basic type (scalar type or void).</td>
</tr>
<tr>
<td><a href="Variables/isBoolean.html">isBoolean</a></td>
<td>Detect whether <code>T</code> is a built-in boolean type or enum of boolean base type.</td>
</tr>
<tr>
<td><a href="Variables/isBuiltinType.html">isBuiltinType</a></td>
<td>Detect whether type <code>T</code> is a builtin type.</td>
</tr>
<tr>
<td><a href="Variables/isConvertibleToString.html">isConvertibleToString</a></td>
<td>$(RED Warning: This trait will be deprecated as soon as it is no longer used in Phobos. For a function parameter to safely accept a type that implicitly converts to string as a string, the conversion needs to happen at the callsite; otherwise, the conversion is done inside the function, and in many cases, that means that local memory is sliced (e.g. if a static array is passed to the function, then it's copied, and the resulting dynamic array will be a slice of a local variable). So, if the resulting string escapes the function, the string refers to invalid memory, and accessing it would mean accessing invalid memory. As such, the only safe way for a function to accept types that implicitly convert to string is for the implicit conversion to be done at the callsite, and that can only occur if the parameter is explicitly typed as an array, whereas using isConvertibleToString in a template constraint would result in the conversion being done inside the function. As such, isConvertibleToString is inherently unsafe and is going to be deprecated.)</td>
</tr>
<tr>
<td><a href="Variables/isCopyable.html">isCopyable</a></td>
<td>Determines whether the type <code>S</code> can be copied. If a type cannot be copied, then code such as <code>MyStruct x; auto y = x;</code> will fail to compile. Copying for structs can be disabled by using <code>@disable this(this)</code> .</td>
</tr>
<tr>
<td><a href="Variables/isDelegate.html">isDelegate</a></td>
<td>Detect whether symbol or type <code>T</code> is a delegate.</td>
</tr>
<tr>
<td><a href="Variables/isEqualityComparable.html">isEqualityComparable</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/isFinalClass.html">isFinalClass</a></td>
<td>Detect whether <code>S</code> is a final class.</td>
</tr>
<tr>
<td><a href="Variables/isFinalFunction.html">isFinalFunction</a></td>
<td>Detect whether <code>S</code> is a final function.</td>
</tr>
<tr>
<td><a href="Variables/isFloatingPoint.html">isFloatingPoint</a></td>
<td>Detect whether <code>T</code> is a built-in floating point type.</td>
</tr>
<tr>
<td><a href="Variables/isFunctionPointer.html">isFunctionPointer</a></td>
<td>Detect whether symbol or type <code>T</code> is a function pointer.</td>
</tr>
<tr>
<td><a href="Variables/isImplicitlyConvertible.html">isImplicitlyConvertible</a></td>
<td>Is <code>From</code> implicitly convertible to <code>To</code> ?</td>
</tr>
<tr>
<td><a href="Variables/isInstanceOf.html">isInstanceOf</a></td>
<td>Returns true if T is an instance of the template S.</td>
</tr>
<tr>
<td><a href="Variables/isInstanceOf.html">isInstanceOf</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/isIterable.html">isIterable</a></td>
<td>Returns <code>true</code> if T can be iterated over using a <code>foreach</code> loop with a single loop variable of automatically inferred type, regardless of how the <code>foreach</code> loop is implemented.  This includes ranges, structs/classes that define <code>opApply</code> with a single loop variable, and builtin dynamic, static and associative arrays.</td>
</tr>
<tr>
<td><a href="Variables/isLvalueAssignable.html">isLvalueAssignable</a></td>
<td>Returns <code>true</code> iff an lvalue of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code> .</td>
</tr>
<tr>
<td><a href="Variables/isMutable.html">isMutable</a></td>
<td>Returns true if T is not const or immutable.  Note that isMutable is true for string, or immutable(char)[], because the 'head' is mutable.</td>
</tr>
<tr>
<td><a href="Variables/isNarrowString.html">isNarrowString</a></td>
<td>Detect whether type <code>T</code> is a narrow string.</td>
</tr>
<tr>
<td><a href="Variables/isNested.html">isNested</a></td>
<td>Determines whether <code>T</code> has its own context pointer. <code>T</code> must be either <code>class</code> , <code>struct</code> , or <code>union</code> .</td>
</tr>
<tr>
<td><a href="Variables/isNestedFunction.html">isNestedFunction</a></td>
<td>Determines if <code>f</code> is a function that requires a context pointer.</td>
</tr>
<tr>
<td><a href="Variables/isOrderingComparable.html">isOrderingComparable</a></td>
<td>Detects whether <code>T</code> is a comparable type. Basic types and structs and classes that implement opCmp are ordering comparable.</td>
</tr>
<tr>
<td><a href="Variables/isPointer.html">isPointer</a></td>
<td>Detect whether type <code>T</code> is a pointer.</td>
</tr>
<tr>
<td><a href="Variables/isQualifierConvertible.html">isQualifierConvertible</a></td>
<td>Is <code>From</code> $(DDSUBLINK spec/const3, implicit_qualifier_conversions, qualifier-convertible) to <code>To</code> ?</td>
</tr>
<tr>
<td><a href="Variables/isRvalueAssignable.html">isRvalueAssignable</a></td>
<td>Returns <code>true</code> iff an rvalue of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code> .</td>
</tr>
<tr>
<td><a href="Variables/isSafe.html">isSafe</a></td>
<td><code>true</code> if <code>func</code> is <code>@safe</code> or <code>@trusted</code> .</td>
</tr>
<tr>
<td><a href="Variables/isScalarType.html">isScalarType</a></td>
<td>Detect whether <code>T</code> is a scalar type (a built-in numeric, character or boolean type).</td>
</tr>
<tr>
<td><a href="Variables/isSigned.html">isSigned</a></td>
<td>Detect whether <code>T</code> is a built-in signed numeric type.</td>
</tr>
<tr>
<td><a href="Variables/isSIMDVector.html">isSIMDVector</a></td>
<td>Detect whether type <code>T</code> is a SIMD vector type.</td>
</tr>
<tr>
<td><a href="Variables/isSomeFunction.html">isSomeFunction</a></td>
<td>Detect whether symbol or type <code>T</code> is a function, a function pointer or a delegate.</td>
</tr>
<tr>
<td><a href="Variables/isSomeString.html">isSomeString</a></td>
<td>Detect whether <code>T</code> is one of the built-in string types.</td>
</tr>
<tr>
<td><a href="Variables/isStaticArray.html">isStaticArray</a></td>
<td>Detect whether type <code>T</code> is a static array.</td>
</tr>
<tr>
<td><a href="Variables/isStorageClassImplicitlyConvertible.html">isStorageClassImplicitlyConvertible</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isType.html">isType</a></td>
<td>Detect whether <code>X</code> is a type. Analogous to <code>is(X)</code> . This is useful when used in conjunction with other templates, e.g. <code>allSatisfy!(isType, X)</code> .</td>
</tr>
<tr>
<td><a href="Variables/isTypeTuple.html">isTypeTuple</a></td>
<td>Check whether the tuple <code>T</code> is a type tuple. A type tuple only contains types.</td>
</tr>
<tr>
<td><a href="Variables/isUnsafe.html">isUnsafe</a></td>
<td><code>true</code> if <code>func</code> is <code>@system</code> .</td>
</tr>
<tr>
<td><a href="Variables/mangledName.html">mangledName</a></td>
<td>Returns the mangled name of symbol or type <code>sth</code> .</td>
</tr>
<tr>
<td><a href="Variables/maxAlignment.html">maxAlignment</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/NameOf.html">NameOf</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/parentPrefix.html">parentPrefix</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/varargs.html">varargs</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/variadicFunctionStyle.html">variadicFunctionStyle</a></td>
<td>ditto</td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
