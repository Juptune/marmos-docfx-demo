<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.typecons | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.typecons | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.typecons.Overview">
<h1 class='section'>Module - std.typecons</h1><h2 class='section'>About</h2><p>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types.</p>
<p>$(SCRIPT inhibitQuickIndex = 1;) $(DIVC quickindex, $(BOOKTABLE, $(TR $(TH Category) $(TH Symbols)) $(TR $(TD Tuple) $(TD $(LREF isTuple) $(LREF Tuple) $(LREF tuple) $(LREF reverse) )) $(TR $(TD Flags) $(TD $(LREF BitFlags) $(LREF isBitFlagEnum) $(LREF Flag) $(LREF No) $(LREF Yes) )) $(TR $(TD Memory allocation) $(TD $(LREF SafeRefCounted) $(LREF safeRefCounted) $(LREF RefCountedAutoInitialize) $(LREF scoped) $(LREF Unique) )) $(TR $(TD Code generation) $(TD $(LREF AutoImplement) $(LREF BlackHole) $(LREF generateAssertTrap) $(LREF generateEmptyFunction) $(LREF WhiteHole) )) $(TR $(TD Nullable) $(TD $(LREF Nullable) $(LREF nullable) $(LREF NullableRef) $(LREF nullableRef) )) $(TR $(TD Proxies) $(TD $(LREF Proxy) $(LREF rebindable) $(LREF Rebindable) $(LREF ReplaceType) $(LREF unwrap) $(LREF wrap) )) $(TR $(TD Types) $(TD $(LREF alignForSize) $(LREF Ternary) $(LREF Typedef) $(LREF TypedefType) $(LREF UnqualRef) )) ))</p>
<p>Copyright: Copyright the respective authors, 2008- License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0). Source:    $(PHOBOSSRC std/typecons.d) Authors:   $(HTTP erdani.org, Andrei Alexandrescu), $(HTTP bartoszmilewski.wordpress.com, Bartosz Milewski), Don Clugston, Shin Fujishiro, Kenji Hara</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/aligned.html">aligned</a></td>
<td>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code> . This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</td>
</tr>
<tr>
<td><a href="Aliases/allMembers.html">allMembers</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/Bind.html">Bind</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/BlackHole.html">BlackHole</a></td>
<td><code>BlackHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions in <code>Base</code> as do-nothing functions.  Each auto-implemented function just returns the default value of the return type without doing anything.</td>
</tr>
<tr>
<td><a href="Aliases/extractName.html">extractName</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/extractType.html">extractType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/fieldSpecs.html">fieldSpecs</a></td>
<td>Tuple of values, for example $(D Tuple!(int, string)) is a record that stores an <code>int</code> and a <code>string</code> . <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code> , the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on.</td>
</tr>
<tr>
<td><a href="Aliases/GetOverloadedMethods.html">GetOverloadedMethods</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/issue10647_DoNothing.html">issue10647_DoNothing</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/OnlyVirtual.html">OnlyVirtual</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Aliases/ReplaceType.html">ReplaceType</a></td>
<td>Replaces all occurrences of <code>From</code> into <code>To</code> , in one or more types <code>T</code> . For example, <code>ReplaceType!(int, uint, Tuple!(int, float)[string])</code> yields <code>Tuple!(uint, float)[string]</code> . The types in which replacement is performed may be arbitrarily complex, including qualifiers, built-in type constructors (pointers, arrays, associative arrays, functions, and delegates), and template instantiations; replacement proceeds transitively through the type definition. However, member types in <code>struct</code> s or <code>class</code> es are not replaced because there are no ways to express the types resulting after replacement.</td>
</tr>
<tr>
<td><a href="Aliases/sharedToString.html">sharedToString</a></td>
<td></td>
</tr>
<tr>
<td><a href="Aliases/sliceSpecs.html">sliceSpecs</a></td>
<td>Tuple of values, for example $(D Tuple!(int, string)) is a record that stores an <code>int</code> and a <code>string</code> . <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code> , the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on.</td>
</tr>
<tr>
<td><a href="Aliases/SourceMembers.html">SourceMembers</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Aliases/TargetMembers.html">TargetMembers</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Aliases/unwrap.html">unwrap</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Aliases/WhiteHole.html">WhiteHole</a></td>
<td><code>WhiteHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions as functions that always fail. These functions simply throw an <code>Error</code> and never return. <code>Whitehole</code> is useful for trapping the use of class member functions that haven't been implemented.</td>
</tr>
<tr>
<td><a href="Aliases/wrap.html">wrap</a></td>
<td>ditto</td>
</tr>
</tbody>
</table>
<h2 class='section'>Classes</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Classes/AutoImplement.html">AutoImplement</a></td>
<td><code>AutoImplement</code> automatically implements (by default) all abstract member functions in the class or interface <code>Base</code> in specified way.</td>
</tr>
<tr>
<td><a href="Classes/AutoImplement.html">AutoImplement</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Classes/Impl.html">Impl</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Classes/issue10647_Foo.html">issue10647_Foo</a></td>
<td></td>
</tr>
<tr>
<td><a href="Classes/NotImplementedError.html">NotImplementedError</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Enums/Flag.html">Flag</a></td>
<td>Defines a simple, self-documenting yes/no flag. This makes it easy for APIs to define functions accepting flags without resorting to $(D bool), which is opaque in calls, and without needing to define an enumerated type separately. Using <code>Flag!&quot;Name&quot;</code> instead of $(D bool) makes the flag's meaning visible in calls. Each yes/no flag has its own type, which makes confusions and mix-ups impossible.</td>
</tr>
<tr>
<td><a href="Enums/RefCountedAutoInitialize.html">RefCountedAutoInitialize</a></td>
<td>Options regarding auto-initialization of a <code>SafeRefCounted</code> object (see the definition of <code>SafeRefCounted</code> below).</td>
</tr>
<tr>
<td><a href="Enums/TypeModifier.html">TypeModifier</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/alignForSize.html">alignForSize</a></td>
<td>Order the provided members to minimize size while preserving alignment. Alignment is not always optimal for 80-bit reals, nor for structs declared as align(1).</td>
</tr>
<tr>
<td><a href="Functions/apply.html">apply</a></td>
<td>Unpacks the content of a <code>Nullable</code> , performs an operation and packs it again. Does nothing if isNull.</td>
</tr>
<tr>
<td><a href="Functions/borrow.html">borrow</a></td>
<td>Borrows the payload of $(LREF SafeRefCounted) for use in <code>fun</code> . Inferred as <code>@safe</code> if <code>fun</code> is <code>@safe</code> and does not escape a reference to the payload. The reference count will be incremented for the duration of the operation, so destroying the last reference will not leave dangling references in <code>fun</code> .</td>
</tr>
<tr>
<td><a href="Functions/dynamicCast.html">dynamicCast</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/issue10647_generateDoNothing.html">issue10647_generateDoNothing</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/nullable.html">nullable</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/nullableRef.html">nullableRef</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/rebindable.html">rebindable</a></td>
<td>Convenience function for creating a <code>Rebindable</code> using automatic type inference.</td>
</tr>
<tr>
<td><a href="Functions/rebindable2.html">rebindable2</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/refCounted.html">refCounted</a></td>
<td>Like $(LREF safeRefCounted) but used to initialize $(LREF RefCounted) instead. Intended for backwards compatibility, otherwise it is preferable to use <code>safeRefCounted</code> .</td>
</tr>
<tr>
<td><a href="Functions/reverse.html">reverse</a></td>
<td>Creates a copy of a $(LREF Tuple) with its fields in reverse order.</td>
</tr>
<tr>
<td><a href="Functions/safeRefCounted.html">safeRefCounted</a></td>
<td>Initializes a <code>SafeRefCounted</code> with <code>val</code> . The template parameter <code>T</code> of <code>SafeRefCounted</code> is inferred from <code>val</code> . This function can be used to move non-copyable values to the heap. It also disables the <code>autoInit</code> option of <code>SafeRefCounted</code> .</td>
</tr>
<tr>
<td><a href="Functions/scoped.html">scoped</a></td>
<td>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code> . This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</td>
</tr>
<tr>
<td><a href="Functions/tuple.html">tuple</a></td>
<td>Constructs a $(LREF Tuple) object instantiated and initialized according to the given arguments.</td>
</tr>
<tr>
<td><a href="Functions/typecons_d_toObject.html">typecons_d_toObject</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/unwrap.html">unwrap</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/wrap.html">wrap</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Interfaces</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Interfaces/Structural.html">Structural</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/BitFlags.html">BitFlags</a></td>
<td>A typesafe structure for storing combinations of enum values.</td>
</tr>
<tr>
<td><a href="Structs/No.html">No</a></td>
<td>Ditto</td>
</tr>
<tr>
<td><a href="Structs/Nullable.html">Nullable</a></td>
<td>Defines a value paired with a distinctive &quot;null&quot; state that denotes the absence of a value. If default constructed, a $(D Nullable!T) object starts in the null state. Assigning it renders it non-null. Calling <code>nullify</code> can nullify it again.</td>
</tr>
<tr>
<td><a href="Structs/Nullable.html">Nullable</a></td>
<td>Just like <code>Nullable!T</code> , except that the null state is defined as a particular value. For example, $(D Nullable!(uint, uint.max)) is an <code>uint</code> that sets aside the value <code>uint.max</code> to denote a null state. $(D Nullable!(T, nullValue)) is more storage-efficient than $(D Nullable!T) because it does not need to store an extra <code>bool</code> .</td>
</tr>
<tr>
<td><a href="Structs/NullableRef.html">NullableRef</a></td>
<td>Just like <code>Nullable!T</code> , except that the object refers to a value sitting elsewhere in memory. This makes assignments overwrite the initially assigned value. Internally <code>NullableRef!T</code> only stores a pointer to <code>T</code> (i.e., $(D Nullable!T.sizeof == (T*).sizeof)).</td>
</tr>
<tr>
<td><a href="Structs/Rebindable.html">Rebindable</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Structs/Rebindable2.html">Rebindable2</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/RefCounted.html">RefCounted</a></td>
<td>The old version of $(LREF SafeRefCounted), before $(LREF borrow) existed. Old code may be relying on <code>@safe</code> ty of some of the member functions which cannot be safe in the new scheme, and can avoid breakage by continuing to use this. <code>SafeRefCounted</code> should be preferred, as this type is outdated and unrecommended for new code.</td>
</tr>
<tr>
<td><a href="Structs/SafeRefCounted.html">SafeRefCounted</a></td>
<td>Defines a reference-counted object containing a <code>T</code> value as payload.</td>
</tr>
<tr>
<td><a href="Structs/Scoped.html">Scoped</a></td>
<td>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code> . This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</td>
</tr>
<tr>
<td><a href="Structs/Ternary.html">Ternary</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Tuple.html">Tuple</a></td>
<td>Tuple of values, for example $(D Tuple!(int, string)) is a record that stores an <code>int</code> and a <code>string</code> . <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code> , the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on.</td>
</tr>
<tr>
<td><a href="Structs/Typedef.html">Typedef</a></td>
<td>$(B Typedef) allows the creation of a unique type which is based on an existing type. Unlike the <code>alias</code> feature, $(B Typedef) ensures the two types are not considered as equals.</td>
</tr>
<tr>
<td><a href="Structs/Unique.html">Unique</a></td>
<td>Encapsulates unique ownership of a resource.</td>
</tr>
<tr>
<td><a href="Structs/Yes.html">Yes</a></td>
<td>Convenience names that allow using e.g. <code>Yes.encryption</code> instead of <code>Flag!&quot;encryption&quot;.yes</code> and <code>No.encryption</code> instead of $(D Flag!&quot;encryption&quot;.no).</td>
</tr>
</tbody>
</table>
<h2 class='section'>Templates</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Templates/AutoImplement_Helper.html">AutoImplement_Helper</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/Concat.html">Concat</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Templates/DerivedFunctionType.html">DerivedFunctionType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/expandSpec.html">expandSpec</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/FieldSpec.html">FieldSpec</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/findCovariantFunction.html">findCovariantFunction</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/follows.html">follows</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/FuncInfo.html">FuncInfo</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/FuncInfo.html">FuncInfo</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/FuncInfo.html">FuncInfo</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Templates/generateEmptyFunction.html">generateEmptyFunction</a></td>
<td>Predefined how-policies for <code>AutoImplement</code> .  These templates are also used by <code>BlackHole</code> and <code>WhiteHole</code> , respectively.</td>
</tr>
<tr>
<td><a href="Templates/hasRequireMethods.html">hasRequireMethods</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Templates/isBitFlagEnum.html">isBitFlagEnum</a></td>
<td>Detect whether an enum is of integral type and has only &quot;flag&quot; values (i.e. values with a bit count of exactly 1). Additionally, a zero value is allowed for compatibility with enums including a &quot;None&quot; value.</td>
</tr>
<tr>
<td><a href="Templates/MemberFunctionGenerator.html">MemberFunctionGenerator</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/OverloadSet.html">OverloadSet</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/parseSpecs.html">parseSpecs</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/Proxy.html">Proxy</a></td>
<td>Creates a proxy for the value <code>a</code> that will forward all operations while disabling implicit conversions. The aliased item <code>a</code> must be an $(B lvalue). This is useful for creating a new type from the &quot;base&quot; type (though this is $(B not) a subtype-supertype relationship; the new type is not related to the old type in any way, by design).</td>
</tr>
<tr>
<td><a href="Templates/Rebindable.html">Rebindable</a></td>
<td><code>Rebindable!(T)</code> is a simple, efficient wrapper that behaves just like an object of type <code>T</code> , except that you can reassign it to refer to another object. For completeness, <code>Rebindable!(T)</code> aliases itself away to <code>T</code> if <code>T</code> is a non-const object type.</td>
</tr>
<tr>
<td><a href="Templates/RebindableCommon.html">RebindableCommon</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/replaceTypeInFunctionTypeUnless.html">replaceTypeInFunctionTypeUnless</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/ReplaceTypeUnless.html">ReplaceTypeUnless</a></td>
<td>Like $(LREF ReplaceType), but does not perform replacement in types for which <code>pred</code> evaluates to <code>true</code> .</td>
</tr>
<tr>
<td><a href="Templates/ReverseTupleSpecs.html">ReverseTupleSpecs</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/ReverseTupleType.html">ReverseTupleType</a></td>
<td></td>
</tr>
<tr>
<td><a href="Templates/TypedefType.html">TypedefType</a></td>
<td>Get the underlying type which a <code>Typedef</code> wraps. If <code>T</code> is not a <code>Typedef</code> it will alias itself to <code>T</code> .</td>
</tr>
<tr>
<td><a href="Templates/Uniq.html">Uniq</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Templates/UnqualRef.html">UnqualRef</a></td>
<td>Similar to <code>Rebindable!(T)</code> but strips all qualifiers from the reference as opposed to just constness / immutability. Primary intended use case is with shared (having thread-local reference to shared class data)</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/alignment.html">alignment</a></td>
<td>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code> . This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</td>
</tr>
<tr>
<td><a href="Variables/areBuildCompatibleTuples.html">areBuildCompatibleTuples</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/areCompatibleTuples.html">areCompatibleTuples</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/distinctFieldNames.html">distinctFieldNames</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/false_.html">false_</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/generateAssertTrap.html">generateAssertTrap</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Variables/hasCopyCtor.html">hasCopyCtor</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/injectNamedFields.html">injectNamedFields</a></td>
<td>Tuple of values, for example $(D Tuple!(int, string)) is a record that stores an <code>int</code> and a <code>string</code> . <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code> , the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on.</td>
</tr>
<tr>
<td><a href="Variables/isBuildable.html">isBuildable</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isBuildableFrom.html">isBuildableFrom</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isDIP1000.html">isDIP1000</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/issue10647_isAlwaysTrue.html">issue10647_isAlwaysTrue</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isTuple.html">isTuple</a></td>
<td>Returns <code>true</code> if and only if <code>T</code> is an instance of <code>std.typecons.Tuple</code> .</td>
</tr>
<tr>
<td><a href="Variables/mod1.html">mod1</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/mod2.html">mod2</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/noMemberHasCopyCtor.html">noMemberHasCopyCtor</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/notFinal.html">notFinal</a></td>
<td>Supports structural based typesafe conversion.</td>
</tr>
<tr>
<td><a href="Variables/sharedToString.html">sharedToString</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/TypeMod.html">TypeMod</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
