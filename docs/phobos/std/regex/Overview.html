<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.regex | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.regex | Marmos Demo ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.regex.Overview">
<h1 class='section'>Module - std.regex</h1><h2 class='section'>About</h2><p>$(LINK2 <a href="https://en.wikipedia.org/wiki/Regular_expression">https://en.wikipedia.org/wiki/Regular_expression</a>, Regular expressions) are a commonly used method of pattern matching on strings, with $(I regex) being a catchy word for a pattern in this domain specific language. Typical problems usually solved by regular expressions include validation of user input and the ubiquitous find $(AMP) replace in text processing utilities.</p>
<p>$(SCRIPT inhibitQuickIndex = 1;) $(DIVC quickindex, $(BOOKTABLE, $(TR $(TH Category) $(TH Functions)) $(TR $(TD Matching) $(TD $(LREF bmatch) $(LREF match) $(LREF matchAll) $(LREF matchFirst) )) $(TR $(TD Building) $(TD $(LREF ctRegex) $(LREF escaper) $(LREF regex) )) $(TR $(TD Replace) $(TD $(LREF replace) $(LREF replaceAll) $(LREF replaceAllInto) $(LREF replaceFirst) $(LREF replaceFirstInto) )) $(TR $(TD Split) $(TD $(LREF split) $(LREF splitter) )) $(TR $(TD Objects) $(TD $(LREF Captures) $(LREF Regex) $(LREF RegexException) $(LREF RegexMatch) $(LREF Splitter) $(LREF StaticRegex) )) ))</p>
<p>$(SECTION Synopsis)</p>
<h3 class='section'>Create a regex at runtime</h3><p>$(RUNNABLE_EXAMPLE $(RUNNABLE_EXAMPLE_STDIN They met on 24/01/1970. 7/8/99 wasn't as hot as 7/8/2022. ) --- import std.regex; import std.stdio; // Print out all possible dd/mm/yy(yy) dates found in user input. auto r = regex(r&quot;\b[0-9][0-9]?/[0-9][0-9]?/[0-9]<a href="?:%5B0-9%5D%5B0-9%5D">0-9</a>?\b&quot;); foreach (line; stdin.byLine) { // matchAll() returns a range that can be iterated // to get all subsequent matches. foreach (c; matchAll(line, r)) writeln(c.hit); } --- ) Create a static regex at compile-time, which contains fast native code: <span class="math">\((RUNNABLE_EXAMPLE --- import std.regex; auto ctr = ctRegex!(`^.*/([^/]+)/?\)</span>`);</p>
<h3 class='section'>// It works just like a normal regex</h3><p>auto c2 = matchFirst(&quot;foo/bar&quot;, ctr);   // First match found here, if any assert(!c2.empty);   // Be sure to check if there is a match before examining contents! assert(c2[1] == &quot;bar&quot;);   // Captures is a range of submatches: 0 = full match. --- ) Multi-pattern regex: $(RUNNABLE_EXAMPLE --- import std.regex; auto multi = regex([<code>\d+,\d+</code>, <code>([a-z]+):(\d+)</code> ]); auto m = &quot;abc:43 12,34&quot;.matchAll(multi); assert(m.front.whichPattern == 2); assert(m.front[1] == &quot;abc&quot;); assert(m.front[2] == &quot;43&quot;); m.popFront(); assert(m.front.whichPattern == 1); assert(m.front[0] == &quot;12,34&quot;); --- ) $(LREF Captures) and <code>opCast!bool</code> : <span class="math">\((RUNNABLE_EXAMPLE --- import std.regex; // The result of `matchAll/matchFirst` is directly testable with `if/assert/while` , // e.g. test if a string consists of letters only: assert(matchFirst(&quot;LettersOnly&quot;, `^\p{L}+\)</span>` ));</p>
<h3 class='section'>// And we can take advantage of the ability to define a variable in the IfCondition</h3><p>if (const captures = matchFirst(&quot;At l34st one digit, but maybe more...&quot;, <code>((\d)(\d*))</code> )) { assert(captures[2] == &quot;3&quot;); assert(captures[3] == &quot;4&quot;); assert(captures[1] == &quot;34&quot;); } --- ) See_Also: $(LINK2 <a href="https://dlang.org/spec/statement.html#IfCondition">https://dlang.org/spec/statement.html#IfCondition</a>, <code>IfCondition</code> ).</p>
<p>$(SECTION Syntax and general information) The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number $(U bounded) in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</p>
<p>The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to <code>std.regex</code> see a $(HTTP dlang.org/regular-expression.html, short tour) of the module API and its abilities.</p>
<p>There are other web resources on regular expressions to help newcomers, and a good $(HTTP <a href="http://www.regular-expressions.info">www.regular-expressions.info</a>, reference with tutorial) can easily be found.</p>
<p>This library uses a remarkably common ECMAScript syntax flavor with the following extensions: $(UL $(LI Named subexpressions, with Python syntax. ) $(LI Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.) $(LI Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.) )</p>
<p>$(REG_START Pattern syntax ) $(I std.regex operates on codepoint level, 'character' in this table denotes a single Unicode codepoint.) $(REG_TABLE $(REG_TITLE Pattern element, Semantics ) $(REG_TITLE Atoms, Match single characters ) <span class="math">\((REG_ROW any character except [{|*+?()^\)</span>, Matches the character itself. ) $(REG_ROW ., In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'. ) $(REG_ROW [class], Matches a single character that belongs to this character class. ) $(REG_ROW [^class], Matches a single character that does $(U not) belong to this character class.) $(REG_ROW \cC, Matches the control character corresponding to letter C) $(REG_ROW \xXX, Matches a character with hexadecimal value of XX. ) $(REG_ROW \uXXXX, Matches a character  with hexadecimal value of XXXX. ) $(REG_ROW \U00YYYYYY, Matches a character with hexadecimal value of YYYYYY. ) $(REG_ROW \f, Matches a formfeed character. ) $(REG_ROW \n, Matches a linefeed character. ) $(REG_ROW \r, Matches a carriage return character. ) $(REG_ROW \t, Matches a tab character. ) $(REG_ROW \v, Matches a vertical tab character. ) $(REG_ROW \d, Matches any Unicode digit. ) $(REG_ROW \D, Matches any character except Unicode digits. ) $(REG_ROW \w, Matches any word character (note: this includes numbers).) $(REG_ROW \W, Matches any non-word character.) $(REG_ROW \s, Matches whitespace, same as \p{White_Space}.) $(REG_ROW \S, Matches any character except those recognized as $(I \s ). ) $(REG_ROW \\, Matches \ character. ) $(REG_ROW \c where c is one of [|*+?(), Matches the character c itself. ) $(REG_ROW \p{PropertyName}, Matches a character that belongs to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}. ) $(REG_ROW  \P{PropertyName}, Matches a character that does not belong to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}. ) $(REG_ROW \p{InBasicLatin}, Matches any character that is part of the BasicLatin Unicode $(U block).) $(REG_ROW \P{InBasicLatin}, Matches any character except ones in the BasicLatin Unicode $(U block).) $(REG_ROW \p{Cyrillic}, Matches any character that is part of Cyrillic $(U script).) $(REG_ROW \P{Cyrillic}, Matches any character except ones in Cyrillic $(U script).) $(REG_TITLE Quantifiers, Specify repetition of other elements) $(REG_ROW , Matches previous character/subexpression 0 or more times. Greedy version - tries as many times as possible.) $(REG_ROW ?, Matches previous character/subexpression 0 or more times. Lazy version  - stops as early as possible.) $(REG_ROW +, Matches previous character/subexpression 1 or more times. Greedy version - tries as many times as possible.) $(REG_ROW +?, Matches previous character/subexpression 1 or more times. Lazy version  - stops as early as possible.) $(REG_ROW ?, Matches previous character/subexpression 0 or 1 time. Greedy version - tries as many times as possible.) $(REG_ROW ??, Matches previous character/subexpression 0 or 1 time. Lazy version  - stops as early as possible.) $(REG_ROW {n}, Matches previous character/subexpression exactly n times. ) <span class="math">\((REG_ROW {n\)</span>(COMMA)}, Matches previous character/subexpression n times or more. Greedy version - tries as many times as possible. ) <span class="math">\((REG_ROW {n\)</span>(COMMA)}?, Matches previous character/subexpression n times or more. Lazy version - stops as early as possible.) <span class="math">\((REG_ROW {n\)</span>(COMMA)m}, Matches previous character/subexpression n to m times. Greedy version - tries as many times as possible, but no more than m times. ) <span class="math">\((REG_ROW {n\)</span>(COMMA)m}?, Matches previous character/subexpression n to m times. Lazy version - stops as early as possible, but no less then n times.) $(REG_TITLE Other, Subexpressions $(AMP) alternations ) $(REG_ROW (regex),  Matches subexpression regex, saving matched portion of text for later retrieval. ) $(REG_ROW (?#comment), An inline comment that is ignored while matching.) $(REG_ROW (?:regex), Matches subexpression regex, $(U not) saving matched portion of text. Useful to speed up matching. ) $(REG_ROW A|B, Matches subexpression A, or failing that, matches B. ) <span class="math">\((REG_ROW (?P\)</span>(LT)name$(GT)regex), Matches named subexpression regex labeling it with name 'name'. When referring to a matched portion of text, names work like aliases in addition to direct numbers. ) $(REG_TITLE Assertions, Match position rather than character ) $(REG_ROW ^, Matches at the beginning of input or line (in multiline mode).) $(REG_ROW $, Matches at the end of input or line (in multiline mode). ) $(REG_ROW \b, Matches at word boundary. ) $(REG_ROW \B, Matches when $(U not) at word boundary. ) $(REG_ROW (?=regex), Zero-width lookahead assertion. Matches at a point where the subexpression regex could be matched starting from the current position. ) $(REG_ROW (?!regex), Zero-width negative lookahead assertion. Matches at a point where the subexpression regex could $(U not) be matched starting from the current position. ) $(REG_ROW (?&lt;=regex), Zero-width lookbehind assertion. Matches at a point where the subexpression regex could be matched ending at the current position (matching goes backwards). ) $(REG_ROW  (?&lt;!regex), Zero-width negative lookbehind assertion. Matches at a point where the subexpression regex could $(U not) be matched ending at the current position (matching goes backwards). ) )</p>
<p>$(REG_START Character classes ) $(REG_TABLE $(REG_TITLE Pattern element, Semantics ) $(REG_ROW Any atom, Has the same meaning as outside of a character class, except for ] which must be written as \]) $(REG_ROW a-z, Includes characters a, b, c, ..., z. ) <span class="math">\((REG_ROW [a||b]\)</span>(COMMA) [a--b]<span class="math">\((COMMA) [a~~b]\)</span>(COMMA) [a$(AMP)$(AMP)b], Where a, b are arbitrary classes, means union, set difference, symmetric set difference, and intersection respectively. $(I Any sequence of character class elements implicitly forms a union.) ) )</p>
<p>$(REG_START Regex flags ) $(REG_TABLE $(REG_TITLE Flag, Semantics ) $(REG_ROW g, Global regex, repeat over the whole input. ) $(REG_ROW i, Case insensitive matching. ) $(REG_ROW m, Multi-line mode, match ^, <span class="math">\(on start and end line separators as well as start and end of input.)\)</span>(REG_ROW s, Single-line mode, makes . match '\n' and '\r' as well. ) $(REG_ROW x, Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions. ) )</p>
<p>$(SECTION Unicode support)</p>
<p>This library provides full Level 1 support* according to $(HTTP unicode.org/reports/tr18/, UTS 18). Specifically: $(UL $(LI 1.1 Hex notation via any of \uxxxx, \U00YYYYYY, \xZZ.) $(LI 1.2 Unicode properties.) $(LI 1.3 Character classes with set operations.) $(LI 1.4 Word boundaries use the full set of &quot;word&quot; characters.) $(LI 1.5 Using simple casefolding to match case insensitively across the full range of codepoints.) $(LI 1.6 Respecting line breaks as any of \u000A | \u000B | \u000C | \u000D | \u0085 | \u2028 | \u2029 | \u000D\u000A.) $(LI 1.7 Operating on codepoint level.) ) With exception of point 1.1.1, as of yet, normalization of input is expected to be enforced by user.</p>
<p>$(SECTION Replace format string)</p>
<p>A set of functions in this module that do the substitution rely on a simple format to guide the process. In particular the table below applies to the <code>format</code> argument of $(LREF replaceFirst) and $(LREF replaceAll).</p>
<p>The format string can reference parts of match using the following notation. $(REG_TABLE $(REG_TITLE Format specifier, Replaced by ) $(REG_ROW <span class="math">\((DOLLAR)\)</span>(AMP), the whole match. ) $(REG_ROW <span class="math">\((DOLLAR)\)</span>(BACKTICK), part of input $(I preceding) the match. ) $(REG_ROW $', part of input $(I following) the match. ) $(REG_ROW $$, '$' character. ) $(REG_ROW \c $(COMMA) where c is any character, the character c itself. ) $(REG_ROW \\, '\' character. ) $(REG_ROW $(DOLLAR)1 .. $(DOLLAR)99, submatch number 1 to 99 respectively. ) )</p>
<p>$(SECTION Slicing and zero memory allocations orientation)</p>
<p>All matches returned by pattern matching functionality in this library are slices of the original input. The notable exception is the <code>replace</code> family of functions  that generate a new string from the input.</p>
<p>In cases where producing the replacement is the ultimate goal $(LREF replaceFirstInto) and $(LREF replaceAllInto) could come in handy as functions that  avoid allocations even for replacement.</p>
<p>Copyright: Copyright Dmitry Olshansky, 2011-</p>
<p>License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).</p>
<p>Authors: Dmitry Olshansky,</p>
<p>API and utility constructs are modeled after the original <code>std.regex</code> by Walter Bright and Andrei Alexandrescu.</p>
<p>Source: $(PHOBOSSRC std/regex/package.d)</p>
<p>Macros: REG_ROW = $(TR $(TD $(I $1 )) $(TD $+) ) REG_TITLE = $(TR $(TD $(B $1)) $(TD $(B $2)) ) REG_TABLE = <table border="1" cellspacing="0" cellpadding="5"> $0 </table> REG_START = <h3><div align="center"> $0 </div></h3> SECTION = <h3><a id="$1" href="#$1" class="anchor">$0</a></h3> S_LINK = <a href="#$1">$+</a>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/Regex.html">Regex</a></td>
<td><code>Regex</code> object holds regular expression pattern in compiled form.</td>
</tr>
<tr>
<td><a href="Aliases/RegexException.html">RegexException</a></td>
<td>Exception object thrown in case of errors during regex compilation.</td>
</tr>
<tr>
<td><a href="Aliases/StaticRegex.html">StaticRegex</a></td>
<td>A <code>StaticRegex</code> is <code>Regex</code> object that contains D code specially generated at compile-time to speed up matching.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/Captures.html">Captures</a></td>
<td><code>Captures</code> object contains submatches captured during a call to <code>match</code> or iteration over <code>RegexMatch</code> range.</td>
</tr>
<tr>
<td><a href="Structs/CTRegexWrapper.html">CTRegexWrapper</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/RegexMatch.html">RegexMatch</a></td>
<td>A regex engine state, as returned by <code>match</code> family of functions.</td>
</tr>
<tr>
<td><a href="Structs/Splitter.html">Splitter</a></td>
<td>Splits a string <code>r</code> using a regular expression <code>pat</code> as a separator.</td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/bmatch.html">bmatch</a></td>
<td>Start matching of <code>input</code> to regex pattern <code>re</code> , using traditional $(LINK2 <a href="https://en.wikipedia.org/wiki/Backtracking">https://en.wikipedia.org/wiki/Backtracking</a>, backtracking) matching scheme.</td>
</tr>
<tr>
<td><a href="Functions/escaper.html">escaper</a></td>
<td>A range that lazily produces a string output escaped to be used inside of a regular expression.</td>
</tr>
<tr>
<td><a href="Functions/match.html">match</a></td>
<td>Start matching <code>input</code> to regex pattern <code>re</code> , using Thompson NFA matching scheme.</td>
</tr>
<tr>
<td><a href="Functions/matchAll.html">matchAll</a></td>
<td>Initiate a search for all non-overlapping matches to the pattern <code>re</code> in the given <code>input</code> . The result is a lazy range of matches generated as they are encountered in the input going left to right.</td>
</tr>
<tr>
<td><a href="Functions/matchFirst.html">matchFirst</a></td>
<td>Find the first (leftmost) slice of the <code>input</code> that matches the pattern <code>re</code> . This function picks the most suitable regular expression engine depending on the pattern properties.</td>
</tr>
<tr>
<td><a href="Functions/matchMany.html">matchMany</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/matchOnce.html">matchOnce</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/matchOnceImpl.html">matchOnceImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/regex.html">regex</a></td>
<td>Compile regular expression pattern for the later execution. Returns: <code>Regex</code> object that works on inputs having the same character width as <code>pattern</code> .</td>
</tr>
<tr>
<td><a href="Functions/regexImpl.html">regexImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/replace.html">replace</a></td>
<td>Old API for replacement, operation depends on flags of pattern <code>re</code> . With &quot;g&quot; flag it performs the equivalent of $(LREF replaceAll) otherwise it works the same as $(LREF replaceFirst).</td>
</tr>
<tr>
<td><a href="Functions/replaceAll.html">replaceAll</a></td>
<td>Construct a new string from <code>input</code> by replacing all of the fragments that match a pattern <code>re</code> with a string generated from the match according to the <code>format</code> specifier.</td>
</tr>
<tr>
<td><a href="Functions/replaceAllInto.html">replaceAllInto</a></td>
<td>A variation on $(LREF replaceAll) that instead of allocating a new string on each call outputs the result piece-wise to the <code>sink</code> . In particular this enables efficient construction of a final output incrementally.</td>
</tr>
<tr>
<td><a href="Functions/replaceAllWith.html">replaceAllWith</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/replaceCapturesInto.html">replaceCapturesInto</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/replaceFirst.html">replaceFirst</a></td>
<td>Construct a new string from <code>input</code> by replacing the first match with a string generated from it according to the <code>format</code> specifier.</td>
</tr>
<tr>
<td><a href="Functions/replaceFirstInto.html">replaceFirstInto</a></td>
<td>A variation on $(LREF replaceFirst) that instead of allocating a new string on each call outputs the result piece-wise to the <code>sink</code> . In particular this enables efficient construction of a final output incrementally.</td>
</tr>
<tr>
<td><a href="Functions/replaceFirstWith.html">replaceFirstWith</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/replaceFmt.html">replaceFmt</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/replaceMatchesInto.html">replaceMatchesInto</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/split.html">split</a></td>
<td>An eager version of <code>splitter</code> that creates an array with splitted slices of <code>input</code> .</td>
</tr>
<tr>
<td><a href="Functions/splitter.html">splitter</a></td>
<td>ditto</td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/ctRegex.html">ctRegex</a></td>
<td>Compile regular expression using CTFE and generate optimized native machine code for matching it.</td>
</tr>
<tr>
<td><a href="Variables/isRegexFor.html">isRegexFor</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isReplaceFunctor.html">isReplaceFunctor</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
