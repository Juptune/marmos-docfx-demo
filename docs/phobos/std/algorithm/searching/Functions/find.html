<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Overloads for - find | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Overloads for - find | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.algorithm.searching.Functions.find">
<h1 class='section'>Overloads for - find</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.algorithm.searching</dd></dl>
</div><h2 class='section api'>find(haystack)   </h2>
 <pre><code class='lang-d'>InputRange find( alias pred, InputRange )( InputRange haystack ) </code></pre><p>Finds an element <code>e</code> of an $(REF_ALTTEXT input range, isInputRange, std,range,primitives) where <code>pred(e)</code> is <code>true</code> . $(P $(PANEL $(UL $(LI <code>find</code> behaves similarly to <code>dropWhile</code> in other languages.) $(LI To find the <em>last</em> matching element in a $(REF_ALTTEXT bidirectional, isBidirectionalRange, std,range,primitives) <code>haystack</code> , call <code>find!pred(retro(haystack))</code> . See $(REF retro, std,range).) )))</p>
<h3 class='section'>Complexity</h3><p><code>find</code> performs $(BIGOH walkLength(haystack)) evaluations of <code>pred</code> .</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>pred</code> &lt;parameter not found&gt;  </dt>
<dd>


<p>The predicate to match an element.</p>

</dd><dt><code>haystack</code> InputRange  </dt>
<dd>


<p>The $(REF_ALTTEXT input range, isInputRange, std,range,primitives) searched in.</p>

</dd></dl><h3 class='section'>Returns</h3><p><code>haystack</code> advanced such that the front element satisfies <code>pred</code> . If no such element exists, returns an empty <code>haystack</code> .</p>
<h2 class='section api'>find(haystack, needle)   </h2>
 <pre><code class='lang-d'>InputRange find(
  alias pred = &quot;a == b&quot;,
  InputRange,
  Element
)(
  InputRange haystack,
  scope Element needle
) </code></pre><p>Finds an individual element in an $(REF_ALTTEXT input range, isInputRange, std,range,primitives). Elements of <code>haystack</code> are compared with <code>needle</code> by using predicate <code>pred</code> with <code>pred(haystack.front, needle)</code> . The predicate is passed to $(REF binaryFun, std, functional), and can either accept a string, or any callable that can be executed via <code>pred(element, element)</code> .</p>
<p>If <code>haystack</code> is a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives), <code>needle</code> can be a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives) too. In this case <code>startsWith!pred(haystack, needle)</code> is evaluated on each evaluation.</p>
<p>$(NOTE To find the first element $(I not) matching the needle, use predicate <code>&quot;a != b&quot;</code> .)</p>
<h3 class='section'>Complexity</h3><p><code>find</code> performs $(BIGOH walkLength(haystack)) evaluations of <code>pred</code> . There are specializations that improve performance by taking advantage of $(REF_ALTTEXT bidirectional, isBidirectionalRange, std,range,primitives) or $(REF_ALTTEXT random access, isRandomAccessRange, std,range,primitives) ranges (where possible).</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>pred</code> &lt;parameter not found&gt;  </dt>
<dd>


<p>The predicate for comparing each element with the needle, defaulting to equality <code>&quot;a == b&quot;</code> .</p>

</dd><dt><code>haystack</code> InputRange  </dt>
<dd>


<p>The $(REF_ALTTEXT input range, isInputRange, std,range,primitives) searched in.</p>

</dd><dt><code>needle</code> Element  </dt>
<dd>


<p>The element searched for.</p>

</dd></dl><h3 class='section'>Returns</h3><p><code>haystack</code> advanced such that the front element is the one searched for; that is, until <code>binaryFun!pred(haystack.front, needle)</code> is <code>true</code> . If no such position exists, returns an empty <code>haystack</code> .</p>
<p>See_Also: $(LREF findAdjacent), $(LREF findAmong), $(LREF findSkip), $(LREF findSplit), $(LREF startsWith)</p>
<h2 class='section api'>find(haystack, needle)   </h2>
 <pre><code class='lang-d'>R1 find( alias pred = &quot;a == b&quot;, R1, R2 )( R1 haystack, scope R2 needle ) </code></pre><p>ditto</p>
<h2 class='section api'>find(haystack, needles)   </h2>
 <pre><code class='lang-d'>Tuple!(Range,size_t) find(
  alias pred = &quot;a == b&quot;,
  Range,
  Needles...
)(
  Range haystack,
  Needles needles
) </code></pre><p>Finds two or more <code>needles</code> into a <code>haystack</code> . The predicate $(D pred) is used throughout to compare elements. By default, elements are compared for equality.</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>pred</code> &lt;parameter not found&gt;  </dt>
<dd>


<p>The predicate to use for comparing elements.</p>

</dd></dl><p>haystack = The target of the search. Must be an input range. If any of <code>needles</code> is a range with elements comparable to elements in <code>haystack</code> , then <code>haystack</code> must be a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives) such that the search can backtrack.</p>
<p>needles = One or more items to search for. Each of <code>needles</code> must be either comparable to one element in <code>haystack</code> , or be itself a forward range with elements comparable with elements in <code>haystack</code> .</p>
<h3 class='section'>Returns</h3><p>A tuple containing <code>haystack</code> positioned to match one of the needles and also the 1-based index of the matching element in $(D needles) (0 if none of <code>needles</code> matched, 1 if <code>needles[0]</code> matched, 2 if <code>needles[1]</code> matched...). The first needle to be found will be the one that matches. If multiple needles are found at the same spot in the range, then the shortest one is the one which matches (if multiple needles of the same length are found at the same spot (e.g <code>&quot;a&quot;</code> and <code>'a'</code> ), then the left-most of them in the argument list matches).</p>
<p>The relationship between <code>haystack</code> and <code>needles</code> simply means that one can e.g. search for individual <code>int</code> s or arrays of $(D int)s in an array of <code>int</code> s. In addition, if elements are individually comparable, searches of heterogeneous types are allowed as well: a <code>double[]</code> can be searched for an <code>int</code> or a $(D short[]), and conversely a <code>long</code> can be searched for a <code>float</code> or a <code>double[]</code> . This makes for efficient searches without the need to coerce one side of the comparison into the other's side type.</p>
<p>The complexity of the search is $(BIGOH haystack.length max(needles.length)). (For needles that are individual items, length is considered to be 1.) The strategy used in searching several subranges at once maximizes cache usage by moving in <code>haystack</code> as few times as possible.</p>
<h2 class='section api'>find(haystack, needle)   </h2>
 <pre><code class='lang-d'>RandomAccessRange find(
  RandomAccessRange,
  alias pred,
  InputRange
)(
  RandomAccessRange haystack,
  scope BoyerMooreFinder!(pred,InputRange) needle
) </code></pre><p>Finds <code>needle</code> in <code>haystack</code> efficiently using the $(LINK2 <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm</a>, Boyer-Moore) method.</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>haystack</code> RandomAccessRange  </dt>
<dd>


<p>A random-access range with length and slicing.</p>

</dd><dt><code>needle</code> BoyerMooreFinder!(pred,InputRange)  </dt>
<dd>


<p>A $(LREF BoyerMooreFinder).</p>

</dd></dl><h3 class='section'>Returns</h3><p><code>haystack</code> advanced such that <code>needle</code> is a prefix of it (if no such position exists, returns <code>haystack</code> advanced to termination).</p>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
