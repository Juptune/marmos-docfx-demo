<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Module - std.algorithm.iteration | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Module - std.algorithm.iteration | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.algorithm.iteration.Overview">
<h1 class='section'>Module - std.algorithm.iteration</h1><h2 class='section'>About</h2><p>This is a submodule of $(MREF std, algorithm). It contains generic iteration algorithms.</p>
<p>$(SCRIPT inhibitQuickIndex = 1;) $(BOOKTABLE Cheat Sheet, $(TR $(TH Function Name) $(TH Description)) $(T2 cache, Eagerly evaluates and caches another range's <code>front</code> .) $(T2 cacheBidirectional, As above, but also provides <code>back</code> and <code>popBack</code> .) $(T2 chunkBy, <code>chunkBy!((a,b) =&gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])</code> returns a range containing 3 subranges: the first with just <code>[1, 1]</code> ; the second with the elements <code>[1, 2]</code> and <code>[2, 2]</code> ; and the third with just <code>[2, 1]</code> .) $(T2 cumulativeFold, <code>cumulativeFold!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns a lazily-evaluated range containing the successive reduced values <code>1</code> , <code>3</code> , <code>6</code> , <code>10</code> .) $(T2 each, <code>each!writeln([1, 2, 3])</code> eagerly prints the numbers <code>1</code> , <code>2</code> and <code>3</code> on their own lines.) $(T2 filter, <code>filter!(a =&gt; a &gt; 0)([1, -1, 2, 0, -3])</code> iterates over elements <code>1</code> and <code>2</code> .) $(T2 filterBidirectional, Similar to <code>filter</code> , but also provides <code>back</code> and <code>popBack</code> at a small increase in cost.) $(T2 fold, <code>fold!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns <code>10</code> .) $(T2 group, <code>group([5, 2, 2, 3, 3])</code> returns a range containing the tuples <code>tuple(5, 1)</code> , <code>tuple(2, 2)</code> , and <code>tuple(3, 2)</code> .) $(T2 joiner, <code>joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)</code> returns a range that iterates over the characters <code>&quot;hello; world!&quot;</code> . No new string is created - the existing inputs are iterated.) $(T2 map, <code>map!(a =&gt; a * 2)([1, 2, 3])</code> lazily returns a range with the numbers <code>2</code> , <code>4</code> , <code>6</code> .) $(T2 mean, Colloquially known as the average, <code>mean([1, 2, 3])</code> returns <code>2</code> .) $(T2 permutations, Lazily computes all permutations using Heap's algorithm.) $(T2 reduce, <code>reduce!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns <code>10</code> . This is the old implementation of <code>fold</code> .) $(T2 splitWhen, Lazily splits a range by comparing adjacent elements.) $(T2 splitter, Lazily splits a range by a separator.) $(T2 substitute, <code>[1, 2].substitute(1, 0.1)</code> returns <code>[0.1, 2]</code> .) $(T2 sum, Same as <code>fold</code> , but specialized for accurate summation.) $(T2 uniq, Iterates over the unique elements in a range, which is assumed sorted.) )</p>
<p>Copyright: Andrei Alexandrescu 2008-.</p>
<p>License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).</p>
<p>Authors: $(HTTP erdani.com, Andrei Alexandrescu)</p>
<p>Source: $(PHOBOSSRC std/algorithm/iteration.d)</p>
<h3 class='section'>Macros</h3><p>T2=$(TR $(TDNW $(LREF $1)) $(TD $+))</p>
<h2 class='section'>Aliases</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Aliases/BinaryArgs.html">BinaryArgs</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Aliases/binfuns.html">binfuns</a></td>
<td>Implements the homonym function (also known as <code>accumulate</code> , $(D compress), <code>inject</code> , or <code>foldl</code> ) present in various programming languages of functional flavor. There is also $(LREF fold) which does the same thing but with the opposite parameter order. The call <code>reduce!(fun)(seed, range)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. Then, for each element <code>x</code> in <code>range</code> , <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>reduce!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</td>
</tr>
<tr>
<td><a href="Aliases/binfuns.html">binfuns</a></td>
<td>Similar to <code>fold</code> , but returns a range containing the successive reduced values. The call <code>cumulativeFold!(fun)(range, seed)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. The returned range contains the values <code>result = fun(result, x)</code> lazily evaluated for each element <code>x</code> in <code>range</code> . Finally, the last element has the same value as <code>fold!(fun)(seed, range)</code> . The one-argument version <code>cumulativeFold!(fun)(range)</code> works similarly, but it returns the first element unchanged and uses it as seed for the next elements. This function is also known as $(HTTP en.cppreference.com/w/cpp/algorithm/partial_sum, partial_sum), $(HTTP docs.python.org/3/library/itertools.html#itertools.accumulate, accumulate), $(HTTP hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scanl, scan), $(HTTP mathworld.wolfram.com/CumulativeSum.html, Cumulative Sum).</td>
</tr>
<tr>
<td><a href="Aliases/ReduceSeedType.html">ReduceSeedType</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Enums</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Enums/GroupingOpType.html">GroupingOpType</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Functions</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Functions/cache.html">cache</a></td>
<td><code>cache</code> eagerly evaluates $(REF_ALTTEXT front, front, std,range,primitives) of <code>range</code> on each construction or call to $(REF_ALTTEXT popFront, popFront, std,range,primitives), to store the result in a cache. The result is then directly returned when $(REF_ALTTEXT front, front, std,range,primitives) is called, rather than re-evaluated.</td>
</tr>
<tr>
<td><a href="Functions/cacheBidirectional.html">cacheBidirectional</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/chunkBy.html">chunkBy</a></td>
<td>Chunks an input range into subranges of equivalent adjacent elements. In other languages this is often called <code>partitionBy</code> , <code>groupBy</code> or <code>sliceWhen</code> .</td>
</tr>
<tr>
<td><a href="Functions/cumulativeFold.html">cumulativeFold</a></td>
<td>Similar to <code>fold</code> , but returns a range containing the successive reduced values. The call <code>cumulativeFold!(fun)(range, seed)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. The returned range contains the values <code>result = fun(result, x)</code> lazily evaluated for each element <code>x</code> in <code>range</code> . Finally, the last element has the same value as <code>fold!(fun)(seed, range)</code> . The one-argument version <code>cumulativeFold!(fun)(range)</code> works similarly, but it returns the first element unchanged and uses it as seed for the next elements. This function is also known as $(HTTP en.cppreference.com/w/cpp/algorithm/partial_sum, partial_sum), $(HTTP docs.python.org/3/library/itertools.html#itertools.accumulate, accumulate), $(HTTP hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scanl, scan), $(HTTP mathworld.wolfram.com/CumulativeSum.html, Cumulative Sum).</td>
</tr>
<tr>
<td><a href="Functions/cumulativeFoldImpl.html">cumulativeFoldImpl</a></td>
<td>Similar to <code>fold</code> , but returns a range containing the successive reduced values. The call <code>cumulativeFold!(fun)(range, seed)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. The returned range contains the values <code>result = fun(result, x)</code> lazily evaluated for each element <code>x</code> in <code>range</code> . Finally, the last element has the same value as <code>fold!(fun)(seed, range)</code> . The one-argument version <code>cumulativeFold!(fun)(range)</code> works similarly, but it returns the first element unchanged and uses it as seed for the next elements. This function is also known as $(HTTP en.cppreference.com/w/cpp/algorithm/partial_sum, partial_sum), $(HTTP docs.python.org/3/library/itertools.html#itertools.accumulate, accumulate), $(HTTP hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scanl, scan), $(HTTP mathworld.wolfram.com/CumulativeSum.html, Cumulative Sum).</td>
</tr>
<tr>
<td><a href="Functions/each.html">each</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Functions/filter.html">filter</a></td>
<td><code>filter!(predicate)(range)</code> returns a new range containing only elements <code>x</code> in <code>range</code> for which <code>predicate(x)</code> returns <code>true</code> .</td>
</tr>
<tr>
<td><a href="Functions/filterBidirectional.html">filterBidirectional</a></td>
<td>Similar to <code>filter</code> , except it defines a $(REF_ALTTEXT bidirectional range, isBidirectionalRange, std,range,primitives). There is a speed disadvantage - the constructor spends time finding the last element in the range that satisfies the filtering condition (in addition to finding the first one). The advantage is that the filtered range can be spanned from both directions. Also, $(REF retro, std,range) can be applied against the filtered range.</td>
</tr>
<tr>
<td><a href="Functions/fold.html">fold</a></td>
<td>Implements the homonym function (also known as <code>accumulate</code> , $(D compress), <code>inject</code> , or <code>foldl</code> ) present in various programming languages of functional flavor, iteratively calling one or more predicates.</td>
</tr>
<tr>
<td><a href="Functions/group.html">group</a></td>
<td>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</td>
</tr>
<tr>
<td><a href="Functions/joiner.html">joiner</a></td>
<td>Lazily joins a range of ranges with a separator. The separator itself is a range. If a separator is not provided, then the ranges are joined directly without anything in between them (often called <code>flatten</code> in other languages).</td>
</tr>
<tr>
<td><a href="Functions/map.html">map</a></td>
<td>Implements the homonym function (also known as <code>transform</code> ) present in many languages of functional flavor. The call <code>map!(fun)(range)</code> returns a range of which elements are obtained by applying <code>fun(a)</code> left to right for all elements <code>a</code> in <code>range</code> . The original ranges are not changed. Evaluation is done lazily.</td>
</tr>
<tr>
<td><a href="Functions/mean.html">mean</a></td>
<td>Finds the mean (colloquially known as the average) of a range.</td>
</tr>
<tr>
<td><a href="Functions/permutations.html">permutations</a></td>
<td>Lazily computes all permutations of <code>r</code> using $(HTTP en.wikipedia.org/wiki/Heap%27s_algorithm, Heap's algorithm).</td>
</tr>
<tr>
<td><a href="Functions/reduce.html">reduce</a></td>
<td>Implements the homonym function (also known as <code>accumulate</code> , $(D compress), <code>inject</code> , or <code>foldl</code> ) present in various programming languages of functional flavor. There is also $(LREF fold) which does the same thing but with the opposite parameter order. The call <code>reduce!(fun)(seed, range)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. Then, for each element <code>x</code> in <code>range</code> , <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>reduce!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</td>
</tr>
<tr>
<td><a href="Functions/reduceImpl.html">reduceImpl</a></td>
<td>Implements the homonym function (also known as <code>accumulate</code> , $(D compress), <code>inject</code> , or <code>foldl</code> ) present in various programming languages of functional flavor. There is also $(LREF fold) which does the same thing but with the opposite parameter order. The call <code>reduce!(fun)(seed, range)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. Then, for each element <code>x</code> in <code>range</code> , <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>reduce!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</td>
</tr>
<tr>
<td><a href="Functions/reducePreImpl.html">reducePreImpl</a></td>
<td>Implements the homonym function (also known as <code>accumulate</code> , $(D compress), <code>inject</code> , or <code>foldl</code> ) present in various programming languages of functional flavor. There is also $(LREF fold) which does the same thing but with the opposite parameter order. The call <code>reduce!(fun)(seed, range)</code> first assigns <code>seed</code> to an internal variable <code>result</code> , also called the accumulator. Then, for each element <code>x</code> in <code>range</code> , <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>reduce!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</td>
</tr>
<tr>
<td><a href="Functions/splitter.html">splitter</a></td>
<td>Lazily splits a range using an element or range as a separator. Separator ranges can be any narrow string type or sliceable range type.</td>
</tr>
<tr>
<td><a href="Functions/splitWhen.html">splitWhen</a></td>
<td>Splits a forward range into subranges in places determined by a binary predicate.</td>
</tr>
<tr>
<td><a href="Functions/substitute.html">substitute</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Functions/sum.html">sum</a></td>
<td>Sums elements of <code>r</code> , which must be a finite $(REF_ALTTEXT input range, isInputRange, std,range,primitives). Although conceptually <code>sum(r)</code> is equivalent to $(LREF fold)!((a, b) =&gt; a + b)(r, 0), <code>sum</code> uses specialized algorithms to maximize accuracy, as follows.</td>
</tr>
<tr>
<td><a href="Functions/sumKahan.html">sumKahan</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/sumPair.html">sumPair</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/sumPairwise.html">sumPairwise</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/sumPairwise16.html">sumPairwise16</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/sumPairwiseN.html">sumPairwiseN</a></td>
<td></td>
</tr>
<tr>
<td><a href="Functions/uniq.html">uniq</a></td>
<td>Lazily iterates unique consecutive elements of the given range, which is assumed to be sorted (functionality akin to the $(HTTP wikipedia.org/wiki/_Uniq, uniq) system utility). Equivalence of elements is assessed by using the predicate <code>pred</code> , by default <code>&quot;a == b&quot;</code> . The predicate is passed to $(REF binaryFun, std,functional), and can either accept a string, or any callable that can be executed via <code>pred(element, element)</code> . If the given range is bidirectional, <code>uniq</code> also yields a $(REF_ALTTEXT bidirectional range, isBidirectionalRange, std,range,primitives).</td>
</tr>
</tbody>
</table>
<h2 class='section'>Structs</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Structs/ChunkByChunkImpl.html">ChunkByChunkImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ChunkByGroup.html">ChunkByGroup</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ChunkByImpl.html">ChunkByImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ChunkByImpl.html">ChunkByImpl</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/ChunkByOuter.html">ChunkByOuter</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/FilterBidiResult.html">FilterBidiResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/FilterResult.html">FilterResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Group.html">Group</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Structs/MapResult.html">MapResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/Permutations.html">Permutations</a></td>
<td>ditto</td>
</tr>
<tr>
<td><a href="Structs/SplitterResult.html">SplitterResult</a></td>
<td></td>
</tr>
<tr>
<td><a href="Structs/UniqResult.html">UniqResult</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Templates</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Templates/ChunkByImplIsUnary.html">ChunkByImplIsUnary</a></td>
<td></td>
</tr>
</tbody>
</table>
<h2 class='section'>Variables</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Variables/hasDifferentAutodecoding.html">hasDifferentAutodecoding</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/isForeachBinaryIterable.html">isForeachBinaryIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isForeachIterable.html">isForeachIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isForeachUnaryIterable.html">isForeachUnaryIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isForeachUnaryWithIndexIterable.html">isForeachUnaryWithIndexIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isRangeBinaryIterable.html">isRangeBinaryIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isRangeIterable.html">isRangeIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/isRangeUnaryIterable.html">isRangeUnaryIterable</a></td>
<td>Eagerly iterates over <code>r</code> and calls <code>fun</code> with each element.</td>
</tr>
<tr>
<td><a href="Variables/needlesAreNarrow.html">needlesAreNarrow</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/s.html">s</a></td>
<td></td>
</tr>
<tr>
<td><a href="Variables/sourceIsNarrow.html">sourceIsNarrow</a></td>
<td></td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
