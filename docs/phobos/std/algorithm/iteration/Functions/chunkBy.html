<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Overloads for - chunkBy | Marmos Demo </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Overloads for - chunkBy | Marmos Demo ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ApiPage">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../logo.svg" alt="Marmos Demo">
            Marmos Demo
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="std.algorithm.iteration.Functions.chunkBy">
<h1 class='section'>Overloads for - chunkBy</h1><div class="facts text-secondary">
<dl><dt>Module</dt><dd>std.algorithm.iteration</dd></dl>
</div><h2 class='section api'>chunkBy(r)   </h2>
 <pre><code class='lang-d'>auto chunkBy( alias pred, Range )( Range r ) </code></pre><p>Chunks an input range into subranges of equivalent adjacent elements. In other languages this is often called <code>partitionBy</code> , <code>groupBy</code> or <code>sliceWhen</code> .</p>
<p>Equivalence is defined by the predicate <code>pred</code> , which can be either binary, which is passed to $(REF binaryFun, std,functional), or unary, which is passed to $(REF unaryFun, std,functional). In the binary form, two range elements <code>a</code> and <code>b</code> are considered equivalent if <code>pred(a,b)</code> is true. In unary form, two elements are considered equivalent if <code>pred(a) == pred(b)</code> is true.</p>
<p>This predicate must be an equivalence relation, that is, it must be reflexive (<code>pred(x,x)</code> is always true), symmetric (<code>pred(x,y) == pred(y,x)</code>), and transitive (<code>pred(x,y) &amp;&amp; pred(y,z)</code> implies <code>pred(x,z)</code> ). If this is not the case, the range returned by chunkBy may assert at runtime or behave erratically. Use $(LREF splitWhen) if you want to chunk by a predicate that is not an equivalence relation.</p>
<h3 class='section'>Params</h3><dl class='parameters'><dt><code>pred</code> &lt;parameter not found&gt;  </dt>
<dd>


<p>Predicate for determining equivalence.</p>

</dd><dt><code>r</code> Range  </dt>
<dd>


<p>An $(REF_ALTTEXT input range, isInputRange, std,range,primitives) to be chunked.</p>

</dd></dl><p>Returns: With a binary predicate, a range of ranges is returned in which all elements in a given subrange are equivalent under the given predicate. With a unary predicate, a range of tuples is returned, with the tuple consisting of the result of the unary predicate for each subrange, and the subrange itself. Copying the range currently has reference semantics, but this may change in the future.</p>
<h3 class='section'>Notes</h3><p>Equivalent elements separated by an intervening non-equivalent element will appear in separate subranges; this function only considers adjacent equivalence. Elements in the subranges will always appear in the same order they appear in the original range.</p>
<h3 class='section'>See_also</h3><p>$(LREF group), which collapses adjacent equivalent elements into a single element.</p>

</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
